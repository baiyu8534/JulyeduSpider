{"list":[{"is_coll":0,"is_done":0,"ques_id":919,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":922,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":923,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":926,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":927,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":929,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":930,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":934,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":941,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":943,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":944,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":955,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":960,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":961,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":965,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":966,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":967,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":970,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":976,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":978,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":979,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":983,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":986,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":987,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":988,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":989,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":990,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":991,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":992,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":993,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":994,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":995,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":997,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1001,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1002,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1004,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1005,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1006,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1007,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1008,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1009,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1011,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1012,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1017,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1020,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1037,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1041,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1042,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1043,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1045,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1046,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1047,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1050,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1051,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1052,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1053,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1054,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1056,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1058,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1061,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1066,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1150,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1225,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1366,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1368,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1524,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1530,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1531,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1550,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1553,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1566,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1567,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1568,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1569,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1571,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1572,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1573,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1698,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1699,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1700,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1701,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1702,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1703,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2076,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2077,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2078,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2079,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2080,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2107,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2116,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2117,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2119,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2120,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2142,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2380,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2381,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2382,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2383,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2385,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2386,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2388,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2390,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2391,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2392,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2393,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2394,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2395,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2396,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2397,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2398,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2399,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2401,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2402,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2403,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2404,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2406,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2407,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2408,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2409,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2410,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2411,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2412,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2413,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2533,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2568,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2569,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2584,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2586,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2587,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2590,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2591,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2595,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2600,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2601,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2602,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2603,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2604,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2662,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2663,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2708,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2709,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2907,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2908,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2914,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2916,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2917,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2919,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2982,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3145,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3146,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3147,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3148,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3149,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3150,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3151,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3152,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3153,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3154,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3155,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3156,"category_id":"23"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":920,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":932,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":935,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":937,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":939,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":942,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":956,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":998,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1000,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1003,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1032,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1040,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1044,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1048,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1049,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1059,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1063,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1149,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1151,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1152,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1362,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1551,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1552,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1554,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1570,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1711,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1712,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1713,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1714,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1715,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1716,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1717,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1823,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1851,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2083,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2084,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2104,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2111,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2112,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2114,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2115,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2121,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2122,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2123,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2124,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2125,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2126,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2127,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2128,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2129,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2130,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2131,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2132,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2137,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2139,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2140,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2141,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2143,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2576,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2577,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2578,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2581,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2582,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2588,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2589,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2597,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2614,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2676,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2749,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2920,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2921,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3004,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3006,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3007,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3009,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3010,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3011,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3012,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3081,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3082,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3083,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3157,"category_id":"26"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":928,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":980,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":982,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":984,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":985,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":1415,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":1416,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":1418,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":1419,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":1420,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2089,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2090,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2091,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2092,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2093,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2094,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2095,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2096,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2097,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2098,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2099,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2100,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2101,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2102,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2567,"category_id":"28"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2103,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2138,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2605,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2606,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2607,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2608,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2609,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2610,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2611,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2612,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2613,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2615,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2616,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2617,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2618,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2619,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2620,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2621,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2622,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2623,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2624,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2625,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2626,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2627,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2628,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2629,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2630,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2631,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2632,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2633,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2634,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2635,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2636,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2637,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2638,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2688,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2689,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2690,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2691,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2693,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2694,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2760,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2918,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2965,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":3075,"category_id":"32"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2753,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2754,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2755,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2756,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2757,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2758,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2759,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2761,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2762,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2763,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2764,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2765,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2856,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2910,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2911,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2912,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2913,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2915,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2964,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2966,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2967,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2968,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2984,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2985,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2986,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2987,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":3005,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":3008,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":3074,"category_id":"30"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2599,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2678,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2679,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2680,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2681,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2682,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2683,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2684,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2685,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2701,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2702,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2707,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2849,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2850,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2851,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2852,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2853,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2854,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2855,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2857,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2858,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2859,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2860,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2861,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2862,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2863,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2864,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2865,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2866,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2867,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2868,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2869,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2870,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2871,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2872,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2873,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2874,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2875,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2876,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2877,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2878,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2879,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2880,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2969,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":3076,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":3077,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":3078,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":3080,"category_id":"33"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2970,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2971,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2972,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2973,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2974,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2975,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2976,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2977,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2978,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2979,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2980,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2981,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2983,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3084,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3085,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3086,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3087,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3088,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3089,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3090,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3091,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3092,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3093,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3094,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3095,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3096,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3097,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3098,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3099,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3100,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3101,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3102,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3103,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3104,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3105,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3106,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3107,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3108,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3109,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3110,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3111,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3112,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3113,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3114,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3115,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3116,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3117,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3118,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3119,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3120,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3121,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3122,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3123,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3124,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3125,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3126,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3127,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3128,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3129,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3130,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3131,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3132,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3133,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3134,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3135,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3136,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3137,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3138,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3139,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3140,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3142,"category_id":"41"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2703,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":2704,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":2705,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":2706,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":2750,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":2752,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":3141,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":3143,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":3144,"category_id":"34"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":1364,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1431,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1432,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1433,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1434,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1457,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1458,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1459,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1460,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1461,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":2585,"category_id":"27"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2086,"category_id":"29"},{"is_coll":0,"is_done":0,"ques_id":2087,"category_id":"29"},{"is_coll":0,"is_done":0,"ques_id":2088,"category_id":"29"},{"is_coll":0,"is_done":0,"ques_id":2110,"category_id":"29"},{"is_coll":0,"is_done":0,"ques_id":2751,"category_id":"29"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":931,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":936,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":938,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":996,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":1462,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":1463,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":1464,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":1465,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":1466,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":1467,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":2900,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":2901,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":2902,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":2903,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":2904,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":2905,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":2906,"category_id":"19"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":906,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":907,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":908,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":909,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":911,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":912,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":913,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":914,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":915,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":916,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":917,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":1575,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":1632,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":1948,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":1949,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2081,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2133,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2134,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2135,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2579,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2580,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2766,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2767,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2768,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2769,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2770,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2771,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2772,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2773,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2774,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2775,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2776,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2777,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2778,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2779,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2780,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2781,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2782,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2783,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2784,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2785,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2786,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2787,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2788,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2789,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2790,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2791,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2792,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2793,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2794,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2795,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2796,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2797,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2798,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2799,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2800,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2801,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2802,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2803,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2804,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2805,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2806,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2807,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2808,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2809,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2810,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2811,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2812,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2813,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2814,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2815,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2816,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2817,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2818,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2819,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2820,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2821,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2822,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2823,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2824,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2825,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2826,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2827,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2828,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2829,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2830,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2831,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2832,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2833,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2834,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2835,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2836,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2837,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2838,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2839,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2840,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2841,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2842,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2843,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2844,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":3079,"category_id":"2"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2570,"category_id":"6"},{"is_coll":0,"is_done":0,"ques_id":2571,"category_id":"6"},{"is_coll":0,"is_done":0,"ques_id":2572,"category_id":"6"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":910,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":933,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1435,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1436,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1437,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1438,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1439,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1440,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1441,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1442,"category_id":"4"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2881,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2882,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2883,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2884,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2885,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2886,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2887,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2888,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2889,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2890,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2891,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2892,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2893,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2894,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2895,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2896,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2897,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2898,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2899,"category_id":"14"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2639,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2640,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2641,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2642,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2643,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2644,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2645,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2646,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2647,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2648,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2649,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2650,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2651,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2652,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2653,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2654,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2655,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2656,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2657,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2658,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2659,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2660,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2661,"category_id":"21"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":1447,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":1448,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":1449,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":1450,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":1451,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2536,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2537,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2538,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2539,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2540,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2541,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2542,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2543,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2544,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2545,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2546,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2547,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2548,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2549,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2550,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2551,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2552,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2553,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2554,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2555,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2556,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2557,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2558,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2559,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2560,"category_id":"3"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":999,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1013,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1443,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1444,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1445,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1446,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1452,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1453,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1455,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":2700,"category_id":"20"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":1454,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2710,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2711,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2712,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2713,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2714,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2715,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2716,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2717,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2718,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2719,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2720,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2721,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2722,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2723,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2724,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2725,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2726,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2727,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2728,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2729,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2730,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2731,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2732,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2733,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2734,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2735,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2736,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2737,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2738,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2739,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2740,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2741,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2742,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2743,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2744,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2745,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2746,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2747,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2748,"category_id":"35"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":919,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":922,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":923,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":926,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":927,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":929,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":930,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":934,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":941,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":943,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":944,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":955,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":960,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":961,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":965,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":966,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":967,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":970,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":976,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":978,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":979,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":983,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":986,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":987,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":988,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":989,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":990,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":991,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":992,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":993,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":994,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":995,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":997,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1001,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1002,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1004,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1005,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1006,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1007,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1008,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1009,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1011,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1012,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1017,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1020,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1037,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1041,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1042,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1043,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1045,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1046,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1047,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1050,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1051,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1052,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1053,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1054,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1056,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1058,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1061,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1066,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1150,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1225,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1366,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1368,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1524,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1530,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1531,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1550,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1553,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1566,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1567,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1568,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1569,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1571,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1572,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1573,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1698,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1699,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1700,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1701,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1702,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":1703,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2076,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2077,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2078,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2079,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2080,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2107,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2116,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2117,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2119,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2120,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2142,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2380,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2381,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2382,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2383,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2385,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2386,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2388,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2390,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2391,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2392,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2393,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2394,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2395,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2396,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2397,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2398,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2399,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2401,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2402,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2403,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2404,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2406,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2407,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2408,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2409,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2410,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2411,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2412,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2413,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2533,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2568,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2569,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2584,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2586,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2587,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2590,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2591,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2595,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2600,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2601,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2602,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2603,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2604,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2662,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2663,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2708,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2709,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2907,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2908,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2914,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2916,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2917,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2919,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":2982,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3145,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3146,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3147,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3148,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3149,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3150,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3151,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3152,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3153,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3154,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3155,"category_id":"23"},{"is_coll":0,"is_done":0,"ques_id":3156,"category_id":"23"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":920,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":932,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":935,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":937,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":939,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":942,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":956,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":998,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1000,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1003,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1032,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1040,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1044,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1048,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1049,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1059,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1063,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1149,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1151,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1152,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1362,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1551,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1552,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1554,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1570,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1711,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1712,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1713,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1714,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1715,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1716,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1717,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1823,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":1851,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2083,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2084,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2104,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2111,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2112,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2114,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2115,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2121,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2122,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2123,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2124,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2125,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2126,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2127,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2128,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2129,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2130,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2131,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2132,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2137,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2139,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2140,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2141,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2143,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2576,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2577,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2578,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2581,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2582,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2588,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2589,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2597,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2614,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2676,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2749,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2920,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":2921,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3004,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3006,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3007,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3009,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3010,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3011,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3012,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3081,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3082,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3083,"category_id":"26"},{"is_coll":0,"is_done":0,"ques_id":3157,"category_id":"26"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":928,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":980,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":982,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":984,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":985,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":1415,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":1416,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":1418,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":1419,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":1420,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2089,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2090,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2091,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2092,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2093,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2094,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2095,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2096,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2097,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2098,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2099,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2100,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2101,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2102,"category_id":"28"},{"is_coll":0,"is_done":0,"ques_id":2567,"category_id":"28"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2103,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2138,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2605,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2606,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2607,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2608,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2609,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2610,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2611,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2612,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2613,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2615,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2616,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2617,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2618,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2619,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2620,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2621,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2622,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2623,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2624,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2625,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2626,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2627,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2628,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2629,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2630,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2631,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2632,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2633,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2634,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2635,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2636,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2637,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2638,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2688,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2689,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2690,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2691,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2693,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2694,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2760,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2918,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":2965,"category_id":"32"},{"is_coll":0,"is_done":0,"ques_id":3075,"category_id":"32"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2753,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2754,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2755,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2756,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2757,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2758,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2759,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2761,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2762,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2763,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2764,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2765,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2856,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2910,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2911,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2912,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2913,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2915,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2964,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2966,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2967,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2968,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2984,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2985,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2986,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":2987,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":3005,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":3008,"category_id":"30"},{"is_coll":0,"is_done":0,"ques_id":3074,"category_id":"30"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2599,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2678,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2679,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2680,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2681,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2682,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2683,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2684,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2685,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2701,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2702,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2707,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2849,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2850,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2851,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2852,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2853,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2854,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2855,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2857,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2858,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2859,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2860,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2861,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2862,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2863,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2864,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2865,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2866,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2867,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2868,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2869,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2870,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2871,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2872,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2873,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2874,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2875,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2876,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2877,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2878,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2879,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2880,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":2969,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":3076,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":3077,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":3078,"category_id":"33"},{"is_coll":0,"is_done":0,"ques_id":3080,"category_id":"33"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2970,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2971,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2972,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2973,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2974,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2975,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2976,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2977,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2978,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2979,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2980,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2981,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":2983,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3084,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3085,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3086,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3087,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3088,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3089,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3090,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3091,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3092,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3093,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3094,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3095,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3096,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3097,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3098,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3099,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3100,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3101,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3102,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3103,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3104,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3105,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3106,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3107,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3108,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3109,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3110,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3111,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3112,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3113,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3114,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3115,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3116,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3117,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3118,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3119,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3120,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3121,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3122,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3123,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3124,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3125,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3126,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3127,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3128,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3129,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3130,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3131,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3132,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3133,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3134,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3135,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3136,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3137,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3138,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3139,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3140,"category_id":"41"},{"is_coll":0,"is_done":0,"ques_id":3142,"category_id":"41"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2703,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":2704,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":2705,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":2706,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":2750,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":2752,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":3141,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":3143,"category_id":"34"},{"is_coll":0,"is_done":0,"ques_id":3144,"category_id":"34"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":1364,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1431,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1432,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1433,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1434,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1457,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1458,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1459,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1460,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":1461,"category_id":"27"},{"is_coll":0,"is_done":0,"ques_id":2585,"category_id":"27"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2086,"category_id":"29"},{"is_coll":0,"is_done":0,"ques_id":2087,"category_id":"29"},{"is_coll":0,"is_done":0,"ques_id":2088,"category_id":"29"},{"is_coll":0,"is_done":0,"ques_id":2110,"category_id":"29"},{"is_coll":0,"is_done":0,"ques_id":2751,"category_id":"29"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":931,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":936,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":938,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":996,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":1462,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":1463,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":1464,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":1465,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":1466,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":1467,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":2900,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":2901,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":2902,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":2903,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":2904,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":2905,"category_id":"19"},{"is_coll":0,"is_done":0,"ques_id":2906,"category_id":"19"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":906,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":907,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":908,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":909,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":911,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":912,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":913,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":914,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":915,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":916,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":917,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":1575,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":1632,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":1948,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":1949,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2081,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2133,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2134,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2135,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2579,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2580,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2766,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2767,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2768,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2769,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2770,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2771,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2772,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2773,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2774,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2775,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2776,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2777,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2778,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2779,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2780,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2781,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2782,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2783,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2784,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2785,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2786,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2787,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2788,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2789,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2790,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2791,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2792,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2793,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2794,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2795,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2796,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2797,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2798,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2799,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2800,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2801,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2802,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2803,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2804,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2805,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2806,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2807,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2808,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2809,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2810,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2811,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2812,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2813,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2814,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2815,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2816,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2817,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2818,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2819,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2820,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2821,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2822,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2823,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2824,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2825,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2826,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2827,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2828,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2829,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2830,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2831,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2832,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2833,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2834,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2835,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2836,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2837,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2838,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2839,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2840,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2841,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2842,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2843,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":2844,"category_id":"2"},{"is_coll":0,"is_done":0,"ques_id":3079,"category_id":"2"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2570,"category_id":"6"},{"is_coll":0,"is_done":0,"ques_id":2571,"category_id":"6"},{"is_coll":0,"is_done":0,"ques_id":2572,"category_id":"6"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":910,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":933,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1435,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1436,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1437,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1438,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1439,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1440,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1441,"category_id":"4"},{"is_coll":0,"is_done":0,"ques_id":1442,"category_id":"4"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2881,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2882,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2883,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2884,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2885,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2886,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2887,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2888,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2889,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2890,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2891,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2892,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2893,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2894,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2895,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2896,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2897,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2898,"category_id":"14"},{"is_coll":0,"is_done":0,"ques_id":2899,"category_id":"14"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":2639,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2640,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2641,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2642,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2643,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2644,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2645,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2646,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2647,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2648,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2649,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2650,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2651,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2652,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2653,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2654,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2655,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2656,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2657,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2658,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2659,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2660,"category_id":"21"},{"is_coll":0,"is_done":0,"ques_id":2661,"category_id":"21"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":1447,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":1448,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":1449,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":1450,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":1451,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2536,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2537,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2538,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2539,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2540,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2541,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2542,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2543,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2544,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2545,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2546,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2547,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2548,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2549,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2550,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2551,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2552,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2553,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2554,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2555,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2556,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2557,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2558,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2559,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2560,"category_id":"3"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":999,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1013,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1443,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1444,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1445,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1446,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1452,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1453,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":1455,"category_id":"20"},{"is_coll":0,"is_done":0,"ques_id":2700,"category_id":"20"}}]}
{"list":[{"is_coll":0,"is_done":0,"ques_id":1454,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2710,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2711,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2712,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2713,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2714,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2715,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2716,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2717,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2718,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2719,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2720,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2721,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2722,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2723,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2724,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2725,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2726,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2727,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2728,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2729,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2730,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2731,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2732,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2733,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2734,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2735,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2736,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2737,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2738,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2739,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2740,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2741,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2742,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2743,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2744,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2745,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2746,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2747,"category_id":"35"},{"is_coll":0,"is_done":0,"ques_id":2748,"category_id":"35"}}]}
{"quesInfo":{"id":2601,"ques":"请详细说说决策树的构造原理\r\n","analysis":"第一部分、决策树学习\r\n1.1、什么是决策树\r\n    咱们直接切入正题。所谓决策树，顾名思义，是一种树，一种依托于策略抉择而建立起来的树。\r\n\r\n    机器学习中，决策树是一个预测模型；他代表的是对象属性与对象值之间的一种映射关系。树中每个节点表示某个对象，而每个分叉路径则代表的某个可能的属性值，而每个叶结点则对应从根节点到该叶节点所经历的路径所表示的对象的值。决策树仅有单一输出，若欲有复数输出，可以建立独立的决策树以处理不同输出。\r\n    从数据产生决策树的机器学习技术叫做决策树学习, 通俗点说就是决策树，说白了，这是一种依托于分类、训练上的预测树，根据已知预测、归类未来。\r\n\r\n    来理论的太过抽象，下面举两个浅显易懂的例子：\r\n\r\n第一个例子\r\n\r\n    套用俗语，决策树分类的思想类似于找对象。现想象一个女孩的母亲要给这个女孩介绍男朋友，于是有了下面的对话：\r\n\r\n      女儿：多大年纪了？\r\n      母亲：26。\r\n      女儿：长的帅不帅？\r\n      母亲：挺帅的。\r\n      女儿：收入高不？\r\n      母亲：不算很高，中等情况。\r\n      女儿：是公务员不？\r\n      母亲：是，在税务局上班呢。\r\n      女儿：那好，我去见见。\r\n\r\n      这个女孩的决策过程就是典型的分类树决策。相当于通过年龄、长相、收入和是否公务员对将男人分为两个类别：见和不见。假设这个女孩对男人的要求是：30岁以下、长相中等以上并且是高收入者或中等以上收入的公务员，那么这个可以用下图表示女孩的决策逻辑：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64153499077293142193.gif'\/>\r\n\r\n也就是说，决策树的简单策略就是，好比公司招聘面试过程中筛选一个人的简历，如果你的条件相当好比如说某985\/211重点大学博士毕业，那么二话不说，直接叫过来面试，如果非重点大学毕业，但实际项目经验丰富，那么也要考虑叫过来面试一下，即所谓具体情况具体分析、决策。但每一个未知的选项都是可以归类到已有的分类类别中的。\r\n\r\n第二个例子\r\n\r\n    此例子来自Tom M.Mitchell著的机器学习一书：\r\n\r\n    小王的目的是通过下周天气预报寻找什么时候人们会打高尔夫，他了解到人们决定是否打球的原因最主要取决于天气情况。而天气状况有晴，云和雨；气温用华氏温度表示；相对湿度用百分比；还有有无风。如此，我们便可以构造一棵决策树，如下（根据天气这个分类决策这天是否合适打网球）：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64153499082525051394.gif'\/>\r\n\r\n上述决策树对应于以下表达式：\r\n（Outlook=Sunny ^Humidity<=70）V （Outlook = Overcast）V （Outlook=Rain ^ Wind=Weak）\r\n\r\n1.2、ID3算法\r\n1.2.1、决策树学习之ID3算法\r\n    ID3算法是决策树算法的一种。想了解什么是ID3算法之前，我们得先明白一个概念：奥卡姆剃刀。\r\n\r\n  • 奥卡姆剃刀（Occam's Razor, Ockham's Razor），又称“奥坎的剃刀”，是由14世纪逻辑学家、圣方济各会修士奥卡姆的威廉（William of Occam，约1285年至1349年）提出，他在《箴言书注》2卷15题说“切勿浪费较多东西，去做‘用较少的东西，同样可以做好的事情’。简单点说，便是：be simple。\r\n\r\n     ID3算法（Iterative Dichotomiser 3 迭代二叉树3代）是一个由Ross Quinlan发明的用于决策树的算法。这个算法便是建立在上述所介绍的奥卡姆剃刀的基础上：越是小型的决策树越优于大的决策树（be simple简单理论）。尽管如此，该算法也不是总是生成最小的树形结构，而是一个启发式算法。\r\n\r\n    OK，从信息论知识中我们知道，期望信息越小，信息增益越大，从而纯度越高。ID3算法的核心思想就是以信息增益度量属性选择，选择分裂后信息增益(很快，由下文你就会知道信息增益又是怎么一回事)最大的属性进行分裂。该算法采用自顶向下的贪婪搜索遍历可能的决策树空间。\r\n\r\n     所以，ID3的思想便是：\r\n\r\n1、自顶向下的贪婪搜索遍历可能的决策树空间构造决策树(此方法是ID3算法和C4.5算法的基础)；\r\n\r\n2、从“哪一个属性将在树的根节点被测试”开始；\r\n\r\n3、使用统计测试来确定每一个实例属性单独分类训练样例的能力，分类能力最好的属性作为树的根结点测试(如何定义或者评判一个属性是分类能力最好的呢？这便是下文将要介绍的信息增益，or 信息增益率)。\r\n\r\n4、然后为根结点属性的每个可能值产生一个分支，并把训练样例排列到适当的分支（也就是说，样例的该属性值对应的分支）之下。\r\n\r\n5、重复这个过程，用每个分支结点关联的训练样例来选取在该点被测试的最佳属性。\r\n这形成了对合格决策树的贪婪搜索，也就是算法从不回溯重新考虑以前的选择。\r\n\r\n    下图所示即是用于学习布尔函数的ID3算法概要：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64153499096749955055.jpg'\/>\r\n\r\n1.2.2、哪个属性是最佳的分类属性\r\n1、信息增益的度量标准：熵\r\n    上文中，我们提到：“ID3算法的核心思想就是以信息增益度量属性选择，选择分裂后信息增益(很快，由下文你就会知道信息增益又是怎么一回事)最大的属性进行分裂。”接下来，咱们就来看看这个信息增益是个什么概念(当然，在了解信息增益之前，你必须先理解：信息增益的度量标准：熵)。\r\n    上述的ID3算法的核心问题是选取在树的每个结点要测试的属性。我们希望选择的是最有利于分类实例的属性，信息增益(Information Gain)是用来衡量给定的属性区分训练样例的能力，而ID3算法在增长树的每一步使用信息增益从候选属性中选择属性。\r\n    为了精确地定义信息增益，我们先定义信息论中广泛使用的一个度量标准，称为熵（entropy），它刻画了任意样例集的纯度（purity）。给定包含关于某个目标概念的正反样例的样例集S，那么S相对这个布尔型分类的熵为：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64153499103358092706.gif'\/>\r\n\r\n上述公式中，p+代表正样例，比如在本文开头第二个例子中p+则意味着去打羽毛球，而p-则代表反样例，不去打球(在有关熵的所有计算中我们定义0log0为0)。\r\n\r\n    如果写代码实现熵的计算，则如下所示：\r\n\r\n\/\/根据具体属性和值来计算熵  \r\ndouble ComputeEntropy(vector <vector <string> > remain_state, string attribute, string value,bool ifparent){  \r\n    vector<int> count (2,0);  \r\n    unsigned int i,j;  \r\n    bool done_flag = false;\/\/哨兵值  \r\n    for(j = 1; j < MAXLEN; j++){  \r\n        if(done_flag) break;  \r\n        if(!attribute_row[j].compare(attribute)){  \r\n            for(i = 1; i < remain_state.size(); i++){  \r\n                if((!ifparent&&!remain_state[i][j].compare(value)) || ifparent){\/\/ifparent记录是否算父节点  \r\n                    if(!remain_state[i][MAXLEN - 1].compare(yes)){  \r\n                        count[0]++;  \r\n                    }  \r\n                    else count[1]++;  \r\n                }  \r\n            }  \r\n            done_flag = true;  \r\n        }  \r\n    }  \r\n    if(count[0] == 0 || count[1] == 0 ) return 0;\/\/全部是正实例或者负实例  \r\n    \/\/具体计算熵 根据[+count[0],-count[1]],log2为底通过换底公式换成自然数底数  \r\n    double sum = count[0] + count[1];  \r\n    double entropy = -count[0]\/sum*log(count[0]\/sum)\/log(2.0) - count[1]\/sum*log(count[1]\/sum)\/log(2.0);  \r\n    return entropy;  \r\n} \r\n\r\n举例来说，假设S是一个关于布尔概念的有14个样例的集合，它包括9个正例和5个反例（我们采用记号[9+，5-]来概括这样的数据样例），那么S相对于这个布尔样例的熵为：\r\n\r\n   Entropy（[9+，5-]）=-（9\/14）log2（9\/14）-（5\/14）log2（5\/14）=0.940。\r\n\r\nSo，根据上述这个公式，我们可以得到：S的所有成员属于同一类，Entropy(S)=0； S的正反样例数量相等，Entropy(S)=1；S的正反样例数量不等，熵介于0，1之间，如下图所示：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64153499159479129313.gif'\/>\r\n\r\n信息论中对熵的一种解释，熵确定了要编码集合S中任意成员的分类所需要的最少二进制位数。更一般地，如果目标属性具有c个不同的值，那么S相对于c个状态的分类的熵定义为：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64153499161233853975.gif'\/>\r\n\r\n Pi为子集合中不同性(而二元分类即正样例和负样例)的样例的比例。\r\n\r\n2、信息增益度量期望的熵降低\r\n\r\n信息增益Gain(S,A)定义\r\n\r\n    已经有了熵作为衡量训练样例集合纯度的标准，现在可以定义属性分类训练数据的效力的度量标准。这个标准被称为“信息增益（information gain）”。简单的说，一个属性的信息增益就是由于使用这个属性分割样例而导致的期望熵降低(或者说，样本按照某属性划分时造成熵减少的期望)。更精确地讲，一个属性A相对样例集合S的信息增益Gain(S,A)被定义为：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64153499164248597567.gif'\/>\r\n\r\n 其中 Values(A)是属性A所有可能值的集合，是S中属性A的值为v的子集。换句话来讲，Gain(S,A)是由于给定属性A的值而得到的关于目标函数值的信息。当对S的一个任意成员的目标值编码时，Gain(S,A)的值是在知道属性A的值后可以节省的二进制位数。\r\n\r\n    接下来，有必要提醒读者一下：关于下面这两个概念 or 公式，\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64153499166982403955.png'\/>\r\n\r\n第一个Entropy(S)是熵定义，第二个则是信息增益Gain(S,A)的定义，而Gain(S,A)由第一个Entropy(S)计算出，记住了。\r\n    下面，举个例子，假定S是一套有关天气的训练样例，描述它的属性包括可能是具有Weak和Strong两个值的Wind。像前面一样，假定S包含14个样例，[9+，5-]。在这14个样例中，假定正例中的6个和反例中的2个有Wind =Weak，其他的有Wind=Strong。由于按照属性Wind分类14个样例得到的信息增益可以计算如下。\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64153499168419745260.jpg'\/>\r\n\r\n运用在本文开头举得第二个根据天气情况是否决定打羽毛球的例子上，得到的最佳分类属性如下图所示：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64153499198928737554.gif'\/>\r\n\r\n 在上图中，计算了两个不同属性：湿度(humidity)和风力(wind)的信息增益，最终humidity这种分类的信息增益0.151>wind增益的0.048。说白了，就是在星期六上午是否适合打网球的问题诀策中，采取humidity较wind作为分类属性更佳，决策树由此而来。\r\n\r\n\/\/计算信息增益，DFS构建决策树  \r\n\/\/current_node为当前的节点  \r\n\/\/remain_state为剩余待分类的样例  \r\n\/\/remian_attribute为剩余还没有考虑的属性  \r\n\/\/返回根结点指针  \r\nNode * BulidDecisionTreeDFS(Node * p, vector <vector <string> > remain_state, vector <string> remain_attribute){  \r\n    \/\/if(remain_state.size() > 0){  \r\n        \/\/printv(remain_state);  \r\n    \/\/}  \r\n    if (p == NULL)  \r\n        p = new Node();  \r\n    \/\/先看搜索到树叶的情况  \r\n    if (AllTheSameLabel(remain_state, yes)){  \r\n        p->attribute = yes;  \r\n        return p;  \r\n    }  \r\n    if (AllTheSameLabel(remain_state, no)){  \r\n        p->attribute = no;  \r\n        return p;  \r\n    }  \r\n    if(remain_attribute.size() == 0){\/\/所有的属性均已经考虑完了,还没有分尽  \r\n        string label = MostCommonLabel(remain_state);  \r\n        p->attribute = label;  \r\n        return p;  \r\n    }  \r\n  \r\n    double max_gain = 0, temp_gain;  \r\n    vector <string>::iterator max_it;  \r\n    vector <string>::iterator it1;  \r\n    for(it1 = remain_attribute.begin(); it1 < remain_attribute.end(); it1++){  \r\n        temp_gain = ComputeGain(remain_state, (*it1));  \r\n        if(temp_gain > max_gain) {  \r\n            max_gain = temp_gain;  \r\n            max_it = it1;  \r\n        }  \r\n    }  \r\n    \/\/下面根据max_it指向的属性来划分当前样例，更新样例集和属性集  \r\n    vector <string> new_attribute;  \r\n    vector <vector <string> > new_state;  \r\n    for(vector <string>::iterator it2 = remain_attribute.begin(); it2 < remain_attribute.end(); it2++){  \r\n        if((*it2).compare(*max_it)) new_attribute.push_back(*it2);  \r\n    }  \r\n    \/\/确定了最佳划分属性，注意保存  \r\n    p->attribute = *max_it;  \r\n    vector <string> values = map_attribute_values[*max_it];  \r\n    int attribue_num = FindAttriNumByName(*max_it);  \r\n    new_state.push_back(attribute_row);  \r\n    for(vector <string>::iterator it3 = values.begin(); it3 < values.end(); it3++){  \r\n        for(unsigned int i = 1; i < remain_state.size(); i++){  \r\n            if(!remain_state[i][attribue_num].compare(*it3)){  \r\n                new_state.push_back(remain_state[i]);  \r\n            }  \r\n        }  \r\n        Node * new_node = new Node();  \r\n        new_node->arrived_value = *it3;  \r\n        if(new_state.size() == 0){\/\/表示当前没有这个分支的样例，当前的new_node为叶子节点  \r\n            new_node->attribute = MostCommonLabel(remain_state);  \r\n        }  \r\n        else   \r\n            BulidDecisionTreeDFS(new_node, new_state, new_attribute);  \r\n        \/\/递归函数返回时即回溯时需要1 将新结点加入父节点孩子容器 2清除new_state容器  \r\n        p->childs.push_back(new_node);  \r\n        new_state.erase(new_state.begin()+1,new_state.end());\/\/注意先清空new_state中的前一个取值的样例，准备遍历下一个取值样例  \r\n    }  \r\n    return p;  \r\n}\r\n\r\n1.2.3、ID3算法决策树的形成\r\n    OK，下图为ID3算法第一步后形成的部分决策树。这样综合起来看，就容易理解多了。1、overcast样例必为正，所以为叶子结点，总为yes；2、ID3无回溯，局部最优，而非全局最优，还有另一种树后修剪决策树。下图是ID3算法第一步后形成的部分决策树：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64153499205754785131.gif'\/>\r\n\r\n 如上图，训练样例被排列到对应的分支结点。分支Overcast的所有样例都是正例，所以成为目标分类为Yes的叶结点。另两个结点将被进一步展开，方法是按照新的样例子集选取信息增益最高的属性。\r\n\r\n1.3、C4.5算法\r\n1.3.1、ID3算法的改进：C4.5算法\r\n    C4.5，是机器学习算法中的另一个分类决策树算法，它是决策树(决策树也就是做决策的节点间的组织方式像一棵树，其实是一个倒树)核心算法，也是上文1.2节所介绍的ID3的改进算法，所以基本上了解了一半决策树构造方法就能构造它。\r\n\r\n    决策树构造方法其实就是每次选择一个好的特征以及分裂点作为当前节点的分类条件。\r\n\r\n    既然说C4.5算法是ID3的改进算法，那么C4.5相比于ID3改进的地方有哪些呢？：\r\n\r\n  1、用信息增益率来选择属性。ID3选择属性用的是子树的信息增益，这里可以用很多方法来定义信息，ID3使用\r\n  的是熵(entropy，熵是一种不纯度度量准则),也就是熵的变化值，而C4.5用的是信息增益率。对，区别就在于一\r\n  个是信息增益，一个是信息增益率。\r\n  2、在树构造过程中进行剪枝，在构造决策树的时候，那些挂着几个元素的节点，不考虑最好，不然容易导致\r\n   overfitting。\r\n  3、对非离散数据也能处理。\r\n  4、能够对不完整数据进行处理\r\n\r\n    针对上述第一点，解释下：一般来说率就是用来取平衡用的，就像方差起的作用差不多，比如有两个跑步的人，一个起点是10m\/s的人、其10s后为20m\/s；另一个人起速是1m\/s、其1s后为2m\/s。如果紧紧算差值那么两个差距就很大了，如果使用速度增加率(加速度，即都是为1m\/s^2)来衡量，2个人就是一样的加速度。因此，C4.5克服了ID3用信息增益选择属性时偏向选择取值多的属性的不足。\r\n\r\nC4.5算法之信息增益率\r\n\r\n    OK，既然上文中提到C4.5用的是信息增益率，那增益率的具体是如何定义的呢？：\r\n\r\n    是的，在这里，C4.5算法不再是通过信息增益来选择决策属性。一个可以选择的度量标准是增益比率gain ratio（Quinlan 1986）。增益比率度量是用前面的增益度量Gain(S，A)和分裂信息度量SplitInformation(S，A)来共同定义的，如下所示：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64153499219046627187.jpg'\/>\r\n\r\n  其中，分裂信息度量被定义为(分裂信息用来衡量属性分裂数据的广度和均匀)：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64153499220924195754.jpg'\/>\r\n\r\n  其中S1到Sc是c个值的属性A分割S而形成的c个样例子集。注意分裂信息实际上就是S关于属性A的各值的熵。这与我们前面对熵的使用不同，在那里我们只考虑S关于学习到的树要预测的目标属性的值的熵。\r\n\r\n    请注意，分裂信息项阻碍选择值为均匀分布的属性。例如，考虑一个含有n个样例的集合被属性A彻底分割（译注：分成n组，即一个样例一组）。这时分裂信息的值为log2n。相反，一个布尔属性B分割同样的n个实例，如果恰好平分两半，那么分裂信息是1。如果属性A和B产生同样的信息增益，那么根据增益比率度量，明显B会得分更高。\r\n\r\n    使用增益比率代替增益来选择属性产生的一个实际问题是，当某个Si接近S（|Si|»|S|）时分母可能为0或非常小。如果某个属性对于S的所有样例有几乎同样的值，这时要么导致增益比率未定义，要么是增益比率非常大。为了避免选择这种属性，我们可以采用这样一些启发式规则，比如先计算每个属性的增益，然后仅对那些增益高过平均值的属性应用增益比率测试（Quinlan 1986）。\r\n\r\n    除了信息增益，Lopez de Mantaras（1991）介绍了另一种直接针对上述问题而设计的度量，它是基于距离的（distance-based）。这个度量标准基于所定义的一个数据划分间的距离尺度。具体更多请参看：Tom M.Mitchhell所著的机器学习之3.7.3节。\r\n\r\n1.3.2、C4.5算法构造决策树的过程\r\n\r\nFunction C4.5(R:包含连续属性的无类别属性集合,C:类别属性,S:训练集)\r\n\/*返回一棵决策树*\/\r\nBegin\r\n   If S为空,返回一个值为Failure的单个节点;\r\n   If S是由相同类别属性值的记录组成,\r\n      返回一个带有该值的单个节点;\r\n   If R为空,则返回一个单节点,其值为在S的记录中找出的频率最高的类别属性值;\r\n   [注意未出现错误则意味着是不适合分类的记录]；\r\n  For 所有的属性R(Ri) Do\r\n        If 属性Ri为连续属性，则\r\n     Begin\r\n           将Ri的最小值赋给A1：\r\n        将Rm的最大值赋给Am；\/*m值手工设置*\/\r\n           For j From 2 To m-1 Do Aj=A1+j*(A1Am)\/m;\r\n           将Ri点的基于{< =Aj,>Aj}的最大信息增益属性(Ri,S)赋给A；\r\n     End；\r\n  将R中属性之间具有最大信息增益的属性(D,S)赋给D;\r\n   将属性D的值赋给{dj\/j=1,2...m}；\r\n  将分别由对应于D的值为dj的记录组成的S的子集赋给{sj\/j=1,2...m}
{"quesInfo":{"id":2916,"ques":"什么是K近邻算法和KD树？","analysis":"本题解析来源于July在CSDN上阅读量超过20万的《从K近邻算法、距离度量谈到KD树、SIFT+BBF算法》\r\n\r\n前言\r\n    前两日，在微博上说：“到今天为止，我至少亏欠了3篇文章待写：1、KD树；2、神经网络；3、编程艺术第28章。你看到，blog内的文章与你于别处所见的任何都不同。于是，等啊等，等一台电脑，只好等待..”。得益于田，借了我一台电脑（借他电脑的时候，我连表示感谢，他说“能找到工作全靠你的博客，这点儿小忙还说，不地道”，有的时候，稍许感受到受人信任也是一种压力，愿我不辜负大家对我的信任），于是今天开始Top 10 Algorithms in Data Mining系列第三篇文章，即本文「从K近邻算法谈到KD树、SIFT+BBF算法」的创作。\r\n\r\n    一个人坚持自己的兴趣是比较难的，因为太多的人太容易为外界所动了，而尤其当你无法从中得到多少实际性的回报时，所幸，我能一直坚持下来。毕达哥拉斯学派有句名言：“万物皆数”，最近读完「微积分概念发展史」后也感受到了这一点。同时，从算法到数据挖掘、机器学习，再到数学，其中每一个领域任何一个细节都值得探索终生，或许，这就是“终生为学”的意思。\r\n\r\n    本文各部分内容分布如下：\r\n\r\n第一部分讲K近邻算法，其中重点阐述了相关的距离度量表示法，\r\n第二部分着重讲K近邻算法的实现--KD树，和KD树的插入，删除，最近邻查找等操作，及KD树的一系列相关改进(包括BBF，M树等)；\r\n第三部分讲KD树的应用：SIFT+kd_BBF搜索算法。\r\n\r\n    同时，你将看到，K近邻算法同本系列的前两篇文章所讲的决策树分类贝叶斯分类，及支持向量机SVM一样，也是用于解决分类问题的算法，\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155283963472895660.jpg'\/>\r\n\r\n    而本数据挖掘十大算法系列也会按照分类，聚类，关联分析，预测回归等问题依次展开阐述。\r\n\r\n    OK，行文仓促，本文若有任何漏洞，问题或者错误，欢迎朋友们随时不吝指正，各位的批评也是我继续写下去的动力之一。感谢。\r\n\r\n\r\n第一部分、K近邻算法\r\n1.1、什么是K近邻算法\r\n    何谓K近邻算法，即K-Nearest Neighbor algorithm，简称KNN算法，单从名字来猜想，可以简单粗暴的认为是：K个最近的邻居，当K=1时，算法便成了最近邻算法，即寻找最近的那个邻居。为何要找邻居？打个比方来说，假设你来到一个陌生的村庄，现在你要找到与你有着相似特征的人群融入他们，所谓入伙。\r\n\r\n    用官方的话来说，所谓K近邻算法，即是给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例（也就是上面所说的K个邻居），这K个实例的多数属于某个类，就把该输入实例分类到这个类中。根据这个说法，咱们来看下引自维基百科上的一幅图：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155283966654403646.png'\/>\r\n\r\n如上图所示，有两类不同的样本数据，分别用蓝色的小正方形和红色的小三角形表示，而图正中间的那个绿色的圆所标示的数据则是待分类的数据。也就是说，现在，我们不知道中间那个绿色的数据是从属于哪一类（蓝色小正方形or红色小三角形），下面，我们就要解决这个问题：给这个绿色的圆分类。\r\n    我们常说，物以类聚，人以群分，判别一个人是一个什么样品质特征的人，常常可以从他\/她身边的朋友入手，所谓观其友，而识其人。我们不是要判别上图中那个绿色的圆是属于哪一类数据么，好说，从它的邻居下手。但一次性看多少个邻居呢？从上图中，你还能看到：\r\n\r\n如果K=3，绿色圆点的最近的3个邻居是2个红色小三角形和1个蓝色小正方形，少数从属于多数，基于统计的方法，判定绿色的这个待分类点属于红色的三角形一类。\r\n如果K=5，绿色圆点的最近的5个邻居是2个红色三角形和3个蓝色的正方形，还是少数从属于多数，基于统计的方法，判定绿色的这个待分类点属于蓝色的正方形一类。\r\n    于此我们看到，当无法判定当前待分类点是从属于已知分类中的哪一类时，我们可以依据统计学的理论看它所处的位置特征，衡量它周围邻居的权重，而把它归为(或分配)到权重更大的那一类。这就是K近邻算法的核心思想。\r\n\r\n1.2、近邻的距离度量表示法\r\n    上文第一节，我们看到，K近邻算法的核心在于找到实例点的邻居，这个时候，问题就接踵而至了，如何找到邻居，邻居的判定标准是什么，用什么来度量。这一系列问题便是下面要讲的距离度量表示法。但有的读者可能就有疑问了，我是要找邻居，找相似性，怎么又跟距离扯上关系了？\r\n\r\n    这是因为特征空间中两个实例点的距离可以反应出两个实例点之间的相似性程度。K近邻模型的特征空间一般是n维实数向量空间，使用的距离可以使欧式距离，也是可以是其它距离，既然扯到了距离，下面就来具体阐述下都有哪些距离度量的表示法，权当扩展。\r\n\r\n1. 欧氏距离，最常见的两点之间或多点之间的距离表示法，又称之为欧几里得度量，它定义于欧几里得空间中，如点 x = (x1,...,xn) 和 y = (y1,...,yn) 之间的距离为：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288092922669125.png'\/>\r\n\r\n(1)二维平面上两点a(x1,y1)与b(x2,y2)间的欧氏距离：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288094923092156.png'\/>\r\n\r\n\r\n(2)三维空间两点a(x1,y1,z1)与b(x2,y2,z2)间的欧氏距离：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase6415528809572677797.png'\/>\r\n\r\n(3)两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的欧氏距离：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288096764741525.png'\/>\r\n\r\n　　也可以用表示成向量运算的形式：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288097428201203.png'\/>\r\n\r\n\r\n\t其上，二维平面上两点欧式距离，代码可以如下编写：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288101480243354.png'\/>\r\n\r\n\r\n2. 曼哈顿距离，我们可以定义曼哈顿距离的正式意义为L1-距离或城市区块距离，也就是在欧几里得空间的固定直角坐标系上两点所形成的线段对轴产生的投影的距离总和。例如在平面上，坐标（x1, y1）的点P1与坐标（x2, y2）的点P2的曼哈顿距离为：<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288105270370125.png'\/>，要注意的是，曼哈顿距离依赖座标系统的转度，而非系统在座标轴上的平移或映射。 \r\n     通俗来讲，想象你在曼哈顿要从一个十字路口开车到另外一个十字路口，驾驶距离是两点间的直线距离吗？显然不是，除非你能穿越大楼。而实际驾驶距离就是这个“曼哈顿距离”，此即曼哈顿距离名称的来源， 同时，曼哈顿距离也称为城市街区距离(City Block distance)。\r\n\r\n(1)二维平面两点a(x1,y1)与b(x2,y2)间的曼哈顿距离 \r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288110594460572.png'\/>\r\n\r\n(2)两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的曼哈顿距离 \r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288111920308418.png'\/>\r\n\r\n3. 切比雪夫距离，若二个向量或二个点p 、and q，其座标分别为Pi及qi，则两者之间的切比雪夫距离定义如下：<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288113557223169.png'\/>，\r\n\r\n 这也等于以下Lp度量的极值：<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288295414730530.png'\/>，因此切比雪夫距离也称为L∞度量。\r\n\r\n    以数学的观点来看，切比雪夫距离是由一致范数（uniform norm）（或称为上确界范数）所衍生的度量，也是超凸度量（injective metric space）的一种。\r\n    在平面几何中，若二点p及q的直角坐标系坐标为(x1,y1)及(x2,y2)，则切比雪夫距离为：。\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288124963104701.png'\/>\r\n    玩过国际象棋的朋友或许知道，国王走一步能够移动到相邻的8个方格中的任意一个。那么国王从格子(x1,y1)走到格子(x2,y2)最少需要多少步？。你会发现最少步数总是max( | x2-x1 | , | y2-y1 | ) 步 。有一种类似的一种距离度量方法叫切比雪夫距离。\r\n(1)二维平面两点a(x1,y1)与b(x2,y2)间的切比雪夫距离 \r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288128990942517.png'\/>\r\n\r\n(2)两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的切比雪夫距离\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288131759181293.png'\/> 　　\r\n\r\n这个公式的另一种等价形式是 \r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288132489278650.png'\/>\r\n\r\n4. 闵可夫斯基距离(Minkowski Distance)，闵氏距离不是一种距离，而是一组距离的定义。\r\n(1) 闵氏距离的定义       \r\n两个n维变量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的闵可夫斯基距离定义为： \r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288134324014217.png'\/>\r\n\r\n其中p是一个变参数。\r\n当p=1时，就是曼哈顿距离\r\n当p=2时，就是欧氏距离\r\n当p→∞时，就是切比雪夫距离       \r\n根据变参数的不同，闵氏距离可以表示一类的距离。 \r\n\r\n5. 标准化欧氏距离 (Standardized Euclidean distance )\r\n标准化欧氏距离是针对简单欧氏距离的缺点而作的一种改进方案。标准欧氏距离的思路：既然数据各维分量的分布不一样，那先将各个分量都“标准化”到均值、方差相等。至于均值和方差标准化到多少，先复习点统计学知识。\r\n\r\n假设样本集X的数学期望或均值(mean)为m，标准差(standard deviation，方差开根)为s，那么X的“标准化变量”X*表示为：(X-m）\/s，而且标准化变量的数学期望为0，方差为1。\r\n即，样本集的标准化过程(standardization)用公式描述就是：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288140374324567.png'\/>\r\n\r\n标准化后的值 =  ( 标准化前的值  － 分量的均值 ) \/分量的标准差　　\r\n经过简单的推导就可以得到两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的标准化欧氏距离的公式：　\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288142651026460.png'\/>\r\n\r\n6. 马氏距离(Mahalanobis Distance)\r\n（1）马氏距离定义       \r\n有M个样本向量X1~Xm，协方差矩阵记为S，均值记为向量μ，则其中样本向量X到u的马氏距离表示为： \r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288151718725531.png'\/>\r\n（协方差矩阵中每个元素是各个矢量元素之间的协方差Cov(X,Y)，Cov(X,Y) = E{ [X-E(X)] [Y-E(Y)]}，其中E为数学期望）\r\n而其中向量Xi与Xj之间的马氏距离定义为：    \r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288153632926588.png'\/>\r\n若协方差矩阵是单位矩阵（各个样本向量之间独立同分布）,则公式就成了：       \r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288154678214804.png'\/>\r\n也就是欧氏距离了。　　\r\n若协方差矩阵是对角矩阵，公式变成了标准化欧氏距离。\r\n\r\n(2)马氏距离的优缺点：量纲无关，排除变量之间的相关性的干扰。 \r\n「微博上的seafood高清版点评道：原来马氏距离是根据协方差矩阵演变，一直被老师误导了，怪不得看Killian在05年NIPS发表的LMNN论文时候老是看到协方差矩阵和半正定，原来是这回事」\r\n\r\n7、巴氏距离（Bhattacharyya Distance）\r\n在统计中，Bhattacharyya距离测量两个离散或连续概率分布的相似性。它与衡量两个统计样品或种群之间的重叠量的Bhattacharyya系数密切相关。Bhattacharyya距离和Bhattacharyya系数以20世纪30年代曾在印度统计研究所工作的一个统计学家A. Bhattacharya命名。同时，Bhattacharyya系数可以被用来确定两个样本被认为相对接近的，它是用来测量中的类分类的可分离性。\r\n（1）巴氏距离的定义\r\n对于离散概率分布 p和q在同一域 X，它被定义为：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288161950349184.png'\/>\r\n其中：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288162519949281.png'\/>\r\n是Bhattacharyya系数。\r\n对于连续概率分布，Bhattacharyya系数被定义为：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288163442613429.png'\/>\r\n\r\n在<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288181055962101.jpg'\/>这两种情况下，巴氏距离DB并没有服从三角不等式.（值得一提的是，Hellinger距离不服从三角不等式）<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288183985074103.jpg'\/>。 \r\n对于多变量的高斯分布<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288185175202173.png'\/> ，\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288186230019781.png'\/>，\r\n\r\n和是手段和协方差的分布<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288187238317124.png'\/>。\r\n需要注意的是，在这种情况下，第一项中的Bhattacharyya距离与马氏距离有关联。 \r\n\r\n（2）Bhattacharyya系数\r\nBhattacharyya系数是两个统计样本之间的重叠量的近似测量，可以被用于确定被考虑的两个样本的相对接近。\r\n计算Bhattacharyya系数涉及集成的基本形式的两个样本的重叠的时间间隔的值的两个样本被分裂成一个选定的分区数，并且在每个分区中的每个样品的成员的数量，在下面的公式中使用\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288189376840133.png'\/>\r\n\r\n考虑样品a 和 b ，n是的分区数，并且<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288190419099455.png'\/>，被一个 和 b i的日分区中的样本数量的成员。更多介绍请参看：http:\/\/en.wikipedia.org\/wiki\/Bhattacharyya_coefficient。\r\n\r\n8. 汉明距离(Hamming distance)\r\n两个等长字符串s1与s2之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。例如字符串“1111”与“1001”之间的汉明距离为2。应用：信息编码（为了增强容错性，应使得编码间的最小汉明距离尽可能大）。\r\n\r\n或许，你还没明白我再说什么，不急，看下上篇blog中第78题的第3小题整理的一道面试题目，便一目了然了。如下图所示：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288196227836227.jpg'\/>\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288196787222276.png'\/>\r\n\r\n与此同时，面试官还可以继续问下去：那么，请问，如何设计一个比较两篇文章相似性的算法？（这个问题的讨论可以看看这里：http:\/\/t.cn\/zl82CAH，及这里关于simhash算法的介绍：http:\/\/www.cnblogs.com\/linecong\/archive\/2010\/08\/28\/simhash.html），接下来，便引出了下文关于夹角余弦的讨论。\r\n（上篇blog中第78题的第3小题给出了多种方法，读者可以参看之。同时，程序员编程艺术系列第二十八章将详细阐述这个问题）\r\n\r\n9. 夹角余弦(Cosine) \r\n几何中夹角余弦可用来衡量两个向量方向的差异，机器学习中借用这一概念来衡量样本向量之间的差异。\r\n(1)在二维空间中向量A(x1,y1)与向量B(x2,y2)的夹角余弦公式：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288202839099788.png'\/>\r\n\r\n(2) 两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)的夹角余弦\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288203561061245.png'\/>      \r\n\r\n类似的，对于两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)，可以使用类似于夹角余弦的概念来衡量它们间的相似程度，即：       \r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288204225128199.png'\/>\r\n\r\n夹角余弦取值范围为[-1,1]。夹角余弦越大表示两个向量的夹角越小，夹角余弦越小表示两向量的夹角越大。当两个向量的方向重合时夹角余弦取最大值1，当两个向量的方向完全相反夹角余弦取最小值-1。 \r\n\r\n10. 杰卡德相似系数(Jaccard similarity coefficient)\r\n(1) 杰卡德相似系数       \r\n两个集合A和B的交集元素在A，B的并集中所占的比例，称为两个集合的杰卡德相似系数，用符号J(A,B)表示。\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288211148951999.png'\/>\r\n杰卡德相似系数是衡量两个集合的相似度一种指标。\r\n\r\n(2) 杰卡德距离       \r\n与杰卡德相似系数相反的概念是杰卡德距离(Jaccard distance)。\r\n杰卡德距离可用如下公式表示：　　\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288212324981846.png'\/>\r\n杰卡德距离用两个集合中不同元素占所有元素的比例来衡量两个集合的区分度。\r\n\r\n(3) 杰卡德相似系数与杰卡德距离的应用      \r\n可将杰卡德相似系数用在衡量样本的相似度上。\r\n举例：样本A与样本B是两个n维向量，而且所有维度的取值都是0或1，例如：A(0111)和B(1011)。我们将样本看成是一个集合，1表示集合包含该元素，0表示集合不包含该元素。\r\n\tM11 ：样本A与B都是1的维度的个数\r\n\tM01：样本A是0，样本B是1的维度的个数\r\n\tM10：样本A是1，样本B是0 的维度的个数\r\n\tM00：样本A与B都是0的维度的个数\r\n依据上文给的杰卡德相似系数及杰卡德距离的相关定义，样本A与B的杰卡德相似系数J可以表示为：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288213653903353.png'\/>\r\n\r\n这里M11+M01+M10可理解为A与B的并集的元素个数，而M11是A与B的交集的元素个数。而样本A与B的杰卡德距离表示为J'：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288214270857926.png'\/>\r\n\r\n11.皮尔逊系数(Pearson Correlation Coefficient)\r\n    在具体阐述皮尔逊相关系数之前，有必要解释下什么是相关系数 ( Correlation coefficient )与相关距离(Correlation distance)。\r\n    相关系数 ( Correlation coefficient )的定义是：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288217518762818.png'\/>\r\n\t\r\n\t(其中，E为数学期望或均值，D为方差，D开根号为标准差，E{ [X-E(X)] [Y-E(Y)]}称为随机变量X与Y的协方差，记为Cov(X,Y)，即Cov(X,Y) = E{ [X-E(X)] [Y-E(Y)]}，而两个变量之间的协方差和标准差的商则称为随机变量X与Y的相关系数，记为Pxy)\r\n   相关系数衡量随机变量X与Y相关程度的一种方法，相关系数的取值范围是[-1,1]。相关系数的绝对值越大，则表明X与Y相关度越高。当X与Y线性相关时，相关系数取值为1（正线性相关）或-1（负线性相关）。\r\n    具体的，如果有两个变量：X、Y，最终计算出的相关系数的含义可以有如下理解：\r\n当相关系数为0时，X和Y两变量无关系。\r\n当X的值增大（减小），Y值增大（减小），两个变量为正相关，相关系数在0.00与1.00之间。\r\n当X的值增大（减小），Y值减小（增大），两个变量为负相关，相关系数在-1.00与0.00之间。\r\n\r\n 相关距离的定义是：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288227847644216.png'\/>\r\n\r\nOK，接下来，咱们来重点了解下皮尔逊相关系数。\r\n    在统计学中，皮尔逊积矩相关系数（英语：Pearson product-moment correlation coefficient，又称作 PPMCC或PCCs, 用r表示）用于度量两个变量X和Y之间的相关（线性相关），其值介于-1与1之间。\r\n通常情况下通过以下取值范围判断变量的相关强度：\r\n相关系数     0.8-1.0     极强相关\r\n                 0.6-0.8     强相关\r\n                 0.4-0.6     中等程度相关\r\n                 0.2-0.4     弱相关\r\n                 0.0-0.2     极弱相关或无相关\r\n\r\n在自然科学领域中，该系数广泛用于度量两个变量之间的相关程度。它是由卡尔·皮尔逊从弗朗西斯·高尔顿在19世纪80年代提出的一个相似却又稍有不同的想法演变而来的。这个相关系数也称作“皮尔森相关系数r”。\r\n\r\n(1)皮尔逊系数的定义：\r\n两个变量之间的皮尔逊相关系数定义为两个变量之间的协方差和标准差的商：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288229134980314.png'\/>\r\n以上方程定义了总体相关系数, 一般表示成希腊字母ρ(rho)。基于样本对协方差和方差进行估计，可以得到样本标准差, 一般表示成r：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288229812192747.png'\/>\r\n一种等价表达式的是表示成标准分的均值。基于(Xi, Yi)的样本点，样本皮尔逊系数是\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288230852154540.png'\/>\r\n               其中<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288232059507212.png'\/>，分别是标准分、样本平均值和样本标准差。\r\n\r\n或许上面的讲解令你头脑混乱不堪，没关系，我换一种方式讲解，如下：\r\n假设有两个变量X、Y，那么两变量间的皮尔逊相关系数可通过以下公式计算：\r\n公式一：<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288245871493180.jpg'\/>\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288247798020326.jpg'\/>\r\n注：勿忘了上面说过，“皮尔逊相关系数定义为两个变量之间的协方差和标准差的商”，其中标准差的计算公式为：\r\n公式二：<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288248619247509.jpg'\/>\r\n公式三：<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288249175923027.jpg'\/>\r\n公式四：<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288249854529520.jpg'\/>\r\n以上列出的四个公式等价，其中E是数学期望，cov表示协方差，N表示变量取值的个数。\r\n\r\n(2)皮尔逊相关系数的适用范围\r\n当两个变量的标准差都不为零时，相关系数才有定义，皮尔逊相关系数适用于：\r\n两个变量之间是线性关系，都是连续数据。\r\n两个变量的总体是正态分布，或接近正态的单峰分布。\r\n两个变量的观测值是成对的，每对观测值之间相互独立。\r\n\r\n(3)如何理解皮尔逊相关系数\r\nrubyist：皮尔逊相关系数理解有两个角度\r\n其一, 按照高中数学水平来理解, 它很简单, 可以看做将两组数据首先做Z分数处理之后, 然后两组数据的乘积和除以样本数，Z分数一般代表正态分布中, 数据偏离中心点的距离.等于变量减掉平均数再除以标准差.(就是高考的标准分类似的处理)\r\n\r\n样本标准差则等于变量减掉平均数的平方和，再除以样本数，最后再开方，也就是说，方差开方即为标准差，样本标准差计算公式为：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase6415528826067411155.jpg'\/>\r\n\r\n所以, 根据这个最朴素的理解,我们可以将公式依次精简为:\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288264659827605.png'\/>\r\n\r\n其二, 按照大学的线性数学水平来理解, 它比较复杂一点,可以看做是两组数据的向量夹角的余弦。下面是关于此皮尔逊系数的几何学的解释，先来看一幅图，如下所示：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288265328129027.png'\/>\r\n\r\n\r\n回归直线： y=gx(x) [红色] 和 x=gy(y) [蓝色]\r\n\r\n如上图，对于没有中心化的数据, 相关系数与两条可能的回归线y=gx(x) 和 x=gy(y) 夹角的余弦值一致。\r\n对于没有中心化的数据 (也就是说, 数据移动一个样本平均值以使其均值为0), 相关系数也可以被视作由两个随机变量 向量 夹角 的 余弦值（见下方）。\r\n\r\n举个例子，例如，有5个国家的国民生产总值分别为 10, 20, 30, 50 和 80 亿美元。 假设这5个国家 (顺序相同) 的贫困百分比分别为 11%, 12%, 13%, 15%, and 18% 。 令 x 和 y 分别为包含上述5个数据的向量: x = (1, 2, 3, 5, 8) 和 y = (0.11, 0.12, 0.13, 0.15, 0.18)。\r\n\r\n利用通常的方法计算两个向量之间的夹角  (参见 数量积), 未中心化 的相关系数是:\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288266531628258.png'\/>\r\n\r\n\r\n我们发现以上的数据特意选定为完全相关: y = 0.10 + 0.01 x。 于是，皮尔逊相关系数应该等于1。将数据中心化 (通过E(x) = 3.8移动 x 和通过 E(y) = 0.138 移动 y ) 得到 x = (−2.8, −1.8, −0.8, 1.2, 4.2) 和 y = (−0.028, −0.018, −0.008, 0.012, 0.042), 从中\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155288267619861010.png'\/>\r\n(4)皮尔逊相关的约束条件\r\n\r\n从以上解释, 也可以理解皮尔逊相关的约束条件:\r\n1 两个变量间有线性关系\r\n2 变量是连续变量\r\n3 变量均符合正态分布,且二元分布也符合正态分布\r\n4 两变量独立\r\n在实践统计中,一般只输出两个系数,一个是相关系数,也就是计算出来的相关系数大小,在-1到1之间;另一个是独立样本检验系数,用来检验样本一致性。\r\n\r\n     简单说来，各种“距离”的应用场景简单概括为，空间：欧氏距离，路径：曼哈顿距离，国际象棋国王：切比雪夫距离，以上三种的统一形式:闵可夫斯基距离，加权：标准化欧氏距离，排除量纲和依存：马氏距离，向量差距：夹角余弦，编码差别：汉明距离，集合近似度：杰卡德类似系数与距离，相关：相关系数与相关距离。\r\n\r\n1.3、K值的选择\r\n    除了上述1.2节如何定义邻居的问题之外，还有一个选择多少个邻居，即K值定义为多大的问题。不要小看了这个K值选择问题，因为它对K近邻算法的结果会产生重大影响。如李航博士的一书「统计学习方法」上所说：\r\n\r\ni)如果选择较小的K值，就相当于用较小的领域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大，换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合；\r\nii)如果选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。\r\niii)K=N，则完全不足取，因为此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的累，模型过于简单，忽略了训练实例中大量有用信息。\r\n\r\n    在实际应用中，K值一般取一个比较小的数值，例如采用交叉验证法（简单来说，就是一部分样本做训练集，一部分做测试集）来选择最优的K值。\r\n\r\n\r\n第二部分、K近邻算法的实现：KD树\r\n2.0、背景\r\n    之前blog内曾经介绍过SIFT特征匹配算法，特征点匹配和数据库查、图像检索本质上是同一个问题，都可以归结为一个通过距离函数在高维矢量之间进行相似性检索的问题，如何快速而准确地找到查询点的近邻，不少人提出了很多高维空间索引结构和近似查询的算法。\r\n\r\n    一般说来，索引结构中相似性查询有两种基本的方式：\r\n\r\n一种是范围查询，范围查询时给定查询点和查询距离阈值，从数据集中查找所有与查询点距离小于阈值的数据\r\n另一种是K近邻查询，就是给定查询点及正整数K，从数据集中找到距离查询点最近的K个数据，当K=1时，它就是最近邻查询。\r\n    同样，针对特征点匹配也有两种方法：\r\n\r\n最容易的办法就是线性扫描，也就是我们常说的穷举搜索，依次计算样本集E中每个样本到输入实例点的距离，然后抽取出计算出来的最小距离的点即为最近邻点。此种办法简单直白，但当样本集或训练集很大时，它的缺点就立马暴露出来了，举个例子，在物体识别的问题中，可能有数千个甚至数万个SIFT特征点，而去一一计算这成千上万的特征点与输入实例点的距离，明显是不足取的。\r\n另外一种，就是构建数据索引，因为实际数据一般都会呈现簇状的聚类形态，因此我们想到建立数据索引，然后再进行快速匹配。索引树是一种树结构索引方法，其基本思想是对搜索空间进行层次划分。根据划分的空间是否有混叠可以分为Clipping和Overlapping两种。前者划分空间没有重叠，其代表就是k-d树；后者划分空间相互有交叠，其代表为R树。\r\n    而关于R树本blog内之前已有介绍(同时，关于基于R树的最近邻查找，还可以看下这篇文章：http:\/\/blog.sina.com.cn\/s\/blog_72e1c7550101dsc3.html)，本文着重介绍k-d树。\r\n\r\n    1975年，来自斯坦福大学的Jon Louis Bentley在ACM杂志上发表的一篇论文：Multidimensional Binary Search Trees Used for Associative Searching 中正式提出和阐述的了如下图形式的把空间划分为多个部分的k-d树。\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155335017673569783.png'\/>\r\n\r\n2.1、什么是KD树\r\n    Kd-树是K-dimension tree的缩写，是对数据点在k维空间（如二维(x，y)，三维(x，y，z)，k维(x1，y，z..)）中划分的一种数据结构，主要应用于多维空间关键数据的搜索（如：范围搜索和最近邻搜索）。本质上说，Kd-树就是一种平衡二叉树。\r\n\r\n    首先必须搞清楚的是，k-d树是一种空间划分树，说白了，就是把整个空间划分为特定的几个部分，然后在特定空间的部分内进行相关搜索操作。想像一个三维(多维有点为难你的想象力了)空间，kd树按照一定的划分规则把这个三维空间划分了多个空间，如下图所示：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155344275027763857.png'\/>\r\n\r\n2.2、KD树的构建\r\n    kd树构建的伪代码如下图所示（伪代码来自《图像局部不变特性特征与描述》王永明 王贵锦 编著）：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155344266926262911.jpg'\/>\r\n\r\n    再举一个简单直观的实例来介绍k-d树构建算法。假设有6个二维数据点{(2,3)，(5,4)，(9,6)，(4,7)，(8,1)，(7,2)}，数据点位于二维空间内，如下图所示。为了能有效的找到最近邻，k-d树采用分而治之的思想，即将整个空间划分为几个小部分，首先，粗黑线将空间一分为二，然后在两个子空间中，细黑直线又将整个空间划分为四部分，最后虚黑直线将这四部分进一步划分。\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155368320742672975.png'\/>\r\n\r\n6个二维数据点{(2,3)，(5,4)，(9,6)，(4,7)，(8,1)，(7,2)}构建kd树的具体步骤为：\r\n\r\n1、确定：split域=x。具体是：6个数据点在x，y维度上的数据方差分别为39，28.63，所以在x轴上方差更大，故split域值为x；\r\n\r\n  2、确定：Node-data = （7,2）。具体是：根据x维上的值将数据排序，6个数据的中值(所谓中值，即中间大小的值)为7，所以Node-data域位数据点（7,2）。这样，该节点的分割超平面就是通过（7,2）并垂直于：split=x轴的直线x=7；\r\n\r\n  3、确定：左子空间和右子空间。具体是：分割超平面x=7将整个空间分为两部分：x<=7的部分为左子空间，包含3个节点={(2,3),(5,4),(4,7)}；另一部分为右子空间，包含2个节点={(9,6)，(8,1)}；\r\n    \r\n  如上算法所述，kd树的构建是一个递归过程，我们对左子空间和右子空间内的数据重复根节点的过程就可以得到一级子节点（5,4）和（9,6），同时将空间和数据集进一步细分，如此往复直到空间中只包含一个数据点。\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155368331380867672.png'\/>\r\n\r\n  与此同时，经过对上面所示的空间划分之后，我们可以看出，点(7,2)可以为根结点，从根结点出发的两条红粗斜线指向的(5,4)和(9,6)则为根结点的左右子结点，而(2,3)，(4,7)则为(5,4)的左右孩子(通过两条细红斜线相连)，最后，(8,1)为(9,6)的左孩子(通过细红斜线相连)。如此，便形成了下面这样一棵k-d树：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155368335593855374.png'\/>\r\n\r\n  k-d树的数据结构\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155368351953759767.png'\/>\r\n\r\n  针对上表给出的kd树的数据结构，转化成具体代码如下所示(注，本文以下代码分析基于Rob Hess维护的sift库)：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155368411210038916.png'\/>\r\n\r\n  也就是说，如之前所述，kd树中，kd代表k-dimension，每个节点即为一个k维的点。每个非叶节点可以想象为一个分割超平面，用垂直于坐标轴的超平面将空间分为两个部分，这样递归的从根节点不停的划分，直到没有实例为止。经典的构造k-d tree的规则如下：\r\n\r\n  随着树的深度增加，循环的选取坐标轴，作为分割超平面的法向量。对于3-d tree来说，根节点选取x轴，根节点的孩子选取y轴，根节点的孙子选取z轴，根节点的曾孙子选取x轴，这样循环下去。\r\n每次均为所有对应实例的中位数的实例作为切分点，切分点作为父节点，左右两侧为划分的作为左右两子树。\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377864387564652.gif'\/>\r\n\r\n  对于n个实例的k维数据来说，建立kd-tree的时间复杂度为O(k*n*logn)。\r\n\r\n  以下是构建k-d树的代码：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377875427713954.png'\/>\r\n\r\n  上面的涉及初始化操作的两个函数kd_node_init，及expand_kd_node_subtree代码分别如下所示：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377877936513332.png'\/>\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377879915820783.png'\/>\r\n\r\n  构建完kd树之后，如今进行最近邻搜索呢？从下面的动态gif图中，你是否能看出些许端倪呢？\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377886229929442.gif'\/>\r\n\r\n  k-d树算法可以分为两大部分，除了上部分有关k-d树本身这种数据结构建立的算法，另一部分是在建立的k-d树上各种诸如插入，删除，查找(最邻近查找)等操作涉及的算法。下面，咱们依次来看kd树的插入、删除、查找操作。\r\n\r\n\r\n2.3、KD树的插入\r\n\r\n  元素插入到一个K-D树的方法和二叉检索树类似。本质上，在偶数层比较x坐标值，而在奇数层比较y坐标值。当我们到达了树的底部，（也就是当一个空指针出现），我们也就找到了结点将要插入的位置。生成的K-D树的形状依赖于结点插入时的顺序。给定N个点，其中一个结点插入和检索的平均代价是O(log2N)。\r\n\r\n  下面4副图(来源：中国地质大学电子课件)说明了插入顺序为(a) Chicago, (b) Mobile, (c) Toronto, and (d) Buffalo，建立空间K-D树的示例：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377895462114526.png'\/>\r\n\r\n  应该清楚，这里描述的插入过程中，每个结点将其所在的平面分割成两部分。因比，Chicago 将平面上所有结点分成两部分，一部分所有的结点x坐标值小于35，另一部分结点的x坐标值大于或等于35。同样Mobile将所有x坐标值大于35的结点以分成两部分，一部分结点的Y坐标值是小于10，另一部分结点的Y坐标值大于或等于10。后面的Toronto、Buffalo也按照一分为二的规则继续划分。\r\n\r\n2.4、KD树的删除\r\n\r\n  KD树的删除可以用递归程序来实现。我们假设希望从K-D树中删除结点（a,b）。如果（a,b）的两个子树都为空，则用空树来代替（a,b）。否则，在（a,b）的子树中寻找一个合适的结点来代替它，譬如(c,d)，则递归地从K-D树中删除（c,d）。一旦(c,d)已经被删除，则用（c,d）代替（a,b）。假设(a,b)是一个X识别器，那么，它得替代节点要么是（a,b）左子树中的X坐标最大值的结点，要么是（a,b）右子树中x坐标最小值的结点。\r\n  也就是说，跟普通二叉树(包括如下图所示的红黑树)结点的删除是同样的思想：用被删除节点A的左子树的最右节点或者A的右子树的最左节点作为替代A的节点(比如，下图红黑树中，若要删除根结点26，第一步便是用23或28取代根结点26)。\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377902131672220.jpg'\/>\r\n\r\n 当(a,b)的右子树为空时，找到（a,b）左子树中具有x坐标最大的结点，譬如（c,d），将(a,b)的左子树放到(c,d)的右子树中，且在树中从它的上一层递归地应用删除过程（也就是（a,b）的左子树） 。\r\n    下面来举一个实际的例子(来源：中国地质大学电子课件，原课件错误已经在下文中订正)，如下图所示，原始图像及对应的kd树，现在要删除图中的A结点，请看一系列删除步骤：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377904784496247.jpg'\/>\r\n\r\n  要删除上图中结点A，选择结点A的右子树中X坐标值最小的结点，这里是C，C成为根，如下图：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377912448672600.jpg'\/>\r\n\r\n  从C的右子树中找出一个结点代替先前C的位置，\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377914973991477.jpg'\/>\r\n\r\n  这里是D，并将D的左子树转为它的右子树，D代替先前C的位置，如下图：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377917753460670.jpg'\/>\r\n\r\n  在D的新右子树中，找X坐标最小的结点，这里为H，H代替D的位置，\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377920028856740.jpg'\/>\r\n\r\n  在D的右子树中找到一个Y坐标最小的值，这里是I，将I代替原先H的位置，从而A结点从图中顺利删除，如下图所示：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase6415537792238505282.jpg'\/>\r\n\r\n  从一个K-D树中删除结点(a,b)的问题变成了在(a,b)的子树中寻找x坐标为最小的结点。不幸的是寻找最小x坐标值的结点比二叉检索树中解决类似的问题要复杂得多。特别是虽然最小x坐标值的结点一定在x识别器的左子树中，但它同样可在y识别器的两个子树中。因此关系到检索，且必须注意检索坐标，以使在每个奇数层仅检索2个子树中的一个。\r\n\r\n  从K-D树中删除一个结点是代价很高的，很清楚删除子树的根受到子树中结点个数的限制。用TPL（T）表示树T总的路径长度。可看出树中子树大小的总和为TPL（T）+N。 以随机方式插入N个点形成树的TPL是O(N*log2N),这就意味着从一个随机形成的K-D树中删除一个随机选取的结点平均代价的上界是O(log2N) 。\r\n\r\n2.5、KD树的最近邻搜索算法\r\n\r\n  现实生活中有许多问题需要在多维数据的快速分析和快速搜索，对于这个问题最常用的方法是所谓的kd树。在k-d树中进行数据的查找也是特征匹配的重要环节，其目的是检索在k-d树中与查询点距离最近的数据点。在一个N维的笛卡儿空间在两个点之间的距离是由下述公式确定：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377935490637181.gif'\/>\r\n\r\n 2.5.1、k-d树查询算法的伪代码\r\n\r\n  k-d树查询算法的伪代码如下所示：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377943526545714.png'\/>\r\n\r\n  读者来信点评@yhxyhxyhx，在“将Kd_point压入search_path堆栈；”这行代码后，应该是调到步骤2再往下走二分搜索的逻辑一直到叶结点，我写了一个递归版本的二维kd tree的搜索函数你对比的看看：\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase6415537794775411079.png'\/>\r\n  \r\n  下面，以两个简单的实例(例子来自图像局部不变特性特征与描述一书)来描述最邻近查找的基本思路。\r\n\r\n 2.5.2、举例：查询点（2.1,3.1）\r\n  \r\n  星号表示要查询的点（2.1,3.1）。通过二叉搜索，顺着搜索路径很快就能找到最邻近的近似点，也就是叶子节点（2,3）。而找到的叶子节点并不一定就是最邻近的，最邻近肯定距离查询点更近，应该位于以查询点为圆心且通过叶子节点的圆域内。为了找到真正的最近邻，还需要进行相关的‘回溯'操作。也就是说，算法首先沿搜索路径反向查找是否有距离查询点更近的数据点。\r\n\r\n  以查询（2.1,3.1）为例：\r\n\r\n    二叉树搜索：先从（7,2）点开始进行二叉查找，然后到达（5,4），最后到达（2,3），此时搜索路径中的节点为<(7,2)，(5,4)，(2,3)>，首先以（2,3）作为当前最近邻点，计算其到查询点（2.1,3.1）的距离为0.1414，\r\n    回溯查找：在得到（2,3）为查询点的最近点之后，回溯到其父节点（5,4），并判断在该父节点的其他子节点空间中是否有距离查询点更近的数据点。以（2.1,3.1）为圆心，以0.1414为半径画圆，如下图所示。发现该圆并不和超平面y = 4交割，因此不用进入（5,4）节点右子空间中(图中灰色区域)去搜索；\r\n    最后，再回溯到（7,2），以（2.1,3.1）为圆心，以0.1414为半径的圆更不会与x = 7超平面交割，因此不用进入（7,2）右子空间进行查找。至此，搜索路径中的节点已经全部回溯完，结束整个搜索，返回最近邻点（2,3），最近距离为0.1414。\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377956885340563.png'\/>\r\n\r\n2.5.3、举例：查询点（2，4.5）\r\n\r\n 一个复杂点了例子如查找点为（2，4.5），具体步骤依次如下：\r\n\r\n    同样先进行二叉查找，先从（7,2）查找到（5,4）节点，在进行查找时是由y = 4为分割超平面的，由于查找点为y值为4.5，因此进入右子空间查找到（4,7），形成搜索路径<(7,2)，(5,4)，(4,7)>，但（4,7）与目标查找点的距离为3.202，而（5,4）与查找点之间的距离为3.041，所以（5,4）为查询点的最近点；\r\n    以（2，4.5）为圆心，以3.041为半径作圆，如下图所示。可见该圆和y = 4超平面交割，所以需要进入（5,4）左子空间进行查找，也就是将（2,3）节点加入搜索路径中得<(7,2)，(2,3)>；于是接着搜索至（2,3）叶子节点，（2,3）距离（2,4.5）比（5,4）要近，所以最近邻点更新为（2，3），最近距离更新为1.5；\r\n    回溯查找至（5,4），直到最后回溯到根结点（7,2）的时候，以（2,4.5）为圆心1.5为半径作圆，并不和x = 7分割超平面交割，如下图所示。至此，搜索路径回溯完，返回最近邻点（2,3），最近距离1.5。\r\n\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377966743482553.png'\/>\r\n\r\n  上述两次实例表明，当查询点的邻域与分割超平面两侧空间交割时，需要查找另一侧子空间，导致检索过程复杂，效率下降。\r\n\r\n\r\n  一般来讲，最临近搜索只需要检测几个叶子结点即可，如下图所示：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377987953868725.jpg'\/>\r\n  但是，如果当实例点的分布比较糟糕时，几乎要遍历所有的结点，如下所示：<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377990184519452.jpg'\/>\r\n研究表明N个节点的K维k-d树搜索过程时间复杂度为：tworst=O（kN1-1\/k）。\r\n\r\n    同时，以上为了介绍方便，讨论的是二维或三维情形。但在实际的应用中，如SIFT特征矢量128维，SURF特征矢量64维，维度都比较大，直接利用k-d树快速检索（维数不超过20）的性能急剧下降，几乎接近贪婪线性扫描。假设数据集的维数为D，一般来说要求数据的规模N满足N»2D，才能达到高效的搜索。所以这就引出了一系列对k-d树算法的改进：BBF算法，和一系列M树、VP树、MVP树等高维空间索引树(下文2.6节kd树近邻搜索算法的改进：BBF算法，与2.7节球树、M树、VP树、MVP树)。\r\n2.6、kd树近邻搜索算法的改进：BBF算法\r\n\r\n    咱们顺着上一节的思路，参考《统计学习方法》一书上的内容，再来总结下kd树的最近邻搜索算法：\r\n\r\n输入：以构造的kd树，目标点x；\r\n输出：x 的最近邻\r\n算法步骤如下：\r\n在kd树种找出包含目标点x的叶结点：从根结点出发，递归地向下搜索kd树。若目标点x当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点，直到子结点为叶结点为止。\r\n以此叶结点为“当前最近点”。\r\n递归的向上回溯，在每个结点进行以下操作：\r\n（a）如果该结点保存的实例点比当前最近点距离目标点更近，则更新“当前最近点”，也就是说以该实例点为“当前最近点”。\r\n（b）当前最近点一定存在于该结点一个子结点对应的区域，检查子结点的父结点的另一子结点对应的区域是否有更近的点。具体做法是，检查另一子结点对应的区域是否以目标点位球心，以目标点与“当前最近点”间的距离为半径的圆或超球体相交：\r\n如果相交，可能在另一个子结点对应的区域内存在距目标点更近的点，移动到另一个子结点，接着，继续递归地进行最近邻搜索；\r\n如果不相交，向上回溯。\r\n当回退到根结点时，搜索结束，最后的“当前最近点”即为x 的最近邻点。\r\n    如果实例点是随机分布的，那么kd树搜索的平均计算复杂度是O（logN），这里的N是训练实例树。所以说，kd树更适用于训练实例数远大于空间维数时的k近邻搜索，当空间维数接近训练实例数时，它的效率会迅速下降，一降降到“解放前”：线性扫描的速度。\r\n\r\n    也正因为上述k最近邻搜索算法的第4个步骤中的所述：“回退到根结点时，搜索结束”，每个最近邻点的查询比较完成过程最终都要回退到根结点而结束，而导致了许多不必要回溯访问和比较到的结点，这些多余的损耗在高维度数据查找的时候，搜索效率将变得相当之地下，那有什么办法可以改进这个原始的kd树最近邻搜索算法呢？\r\n\r\n    从上述标准的kd树查询过程可以看出其搜索过程中的“回溯”是由“查询路径”决定的，并没有考虑查询路径上一些数据点本身的一些性质。一个简单的改进思路就是将“查询路径”上的结点进行排序，如按各自分割超平面（也称bin）与查询点的距离排序，也就是说，回溯检查总是从优先级最高（Best Bin）的树结点开始。\r\n\r\n    针对此BBF机制，读者Feng&书童点评道：\r\n\r\n在某一层，分割面是第ki维，分割值是kv，那么 abs(q[ki]-kv) 就是没有选择的那个分支的优先级，也就是计算的是那一维上的距离；\r\n同时，从优先队列里面取节点只在某次搜索到叶节点后才发生，计算过距离的节点不会出现在队列的，比如1~10这10个节点，你第一次搜索到叶节点的路径是1-5-7，那么1，5，7是不会出现在优先队列的。换句话说，优先队列里面存的都是查询路径上节点对应的相反子节点，比如：搜索左子树，就把对应这一层的右节点存进队列。\r\n    如此，就引出了本节要讨论的kd树最近邻搜索算法的改进：BBF（Best-Bin-First）查询算法，它是由发明sift算法的David Lowe在1997的一篇文章中针对高维数据提出的一种近似算法，此算法能确保优先检索包含最近邻点可能性较高的空间，此外，BBF机制还设置了一个运行超时限定。采用了BBF查询机制后，kd树便可以有效的扩展到高维数据集上。\r\n\r\n    伪代码如下图所示（图取自图像局部不变特性特征与描述一书）：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377995731705864.jpg'\/>\r\n 还是以上面的查询（2,4.5）为例，搜索的算法流程为：\r\n\r\n将（7,2）压人优先队列中；\r\n提取优先队列中的（7,2），由于（2,4.5）位于（7,2）分割超平面的左侧，所以检索其左子结点（5,4）。同时，根据BBF机制”搜索左\/右子树，就把对应这一层的兄弟结点即右\/左结点存进队列”，将其（5,4）对应的兄弟结点即右子结点（9,6）压人优先队列中，此时优先队列为{（9,6）}，最佳点为（7,2）；然后一直检索到叶子结点（4,7），此时优先队列为{（2,3），（9,6）}，“最佳点”则为（5,4）；\r\n提取优先级最高的结点（2,3），重复步骤2，直到优先队列为空。\r\n\r\n    如你在下图所见到的那样（话说，用鼠标在图片上写字着实不好写）：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155377998951412539.jpg'\/><img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155378000183167311.jpg'\/>\r\n2.7、球树、M树、VP树、MVP树\r\n\r\n2.7.1、球树\r\n\r\n    咱们来针对上文内容总结回顾下，针对下面这样一棵kd树：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155378002590646627.jpg'\/>\r\n现要找它的最近邻。\r\n\r\n    通过上文2.5节，总结来说，我们已经知道：\r\n\r\n\t1、为了找到一个给定目标点的最近邻，需要从树的根结点开始向下沿树找出目标点所在的区域，如下图所示，给定目标点，用星号标示，我们似乎一眼看出，有一个点离目标点最近，因为它落在以目标点为圆心以较小长度为半径的虚线圆内，但为了确定是否可能还村庄一个最近的近邻，我们会先检查叶节点的同胞结点，然叶节点的同胞结点在图中所示的阴影部分，虚线圆并不与之相交，所以确定同胞叶结点不可能包含更近的近邻。\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155378006652438817.jpg'\/>\r\n\r\n        2、于是我们回溯到父节点，并检查父节点的同胞结点，父节点的同胞结点覆盖了图中所有横线X轴上的区域。因为虚线圆与右上方的矩形(KD树把二维平面划分成一个一个矩形)相交...\r\n\r\n    如上，我们看到，KD树是可用于有效寻找最近邻的一个树结构，但这个树结构其实并不完美，当处理不均匀分布的数据集时便会呈现出一个基本冲突：既邀请树有完美的平衡结构，又要求待查找的区域近似方形，但不管是近似方形，还是矩形，甚至正方形，都不是最好的使用形状，因为他们都有角。\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155378009067949062.jpg'\/>\r\n\r\n  什么意思呢？就是说，在上图中，如果黑色的实例点离目标点星点再远一点，那么势必那个虚线圆会如红线所示那样扩大，以致与左上方矩形的右下角相交，既然相交了，那么势必又必须检查这个左上方矩形，而实际上，最近的点离星点的距离很近，检查左上方矩形区域已是多余。于此我们看见，KD树把二维平面划分成一个一个矩形，但矩形区域的角却是个难以处理的问题。\r\n\r\n    解决的方案就是使用如下图所示的球树：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155378011414155697.jpg'\/>\r\n先从球中选择一个离球的中心最远的点，然后选择第二个点离第一个点最远，将球中所有的点分配到离这两个聚类中心最近的一个上，然后计算每个聚类的中心，以及聚类能够包含它所有数据点所需的最小半径。这种方法的优点是分裂一个包含n个殊绝点的球的成本只是随n呈线性增加\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase6415537801389805144.jpg'\/>\r\n\r\n 使用球树找出给定目标点的最近邻方法是，首先自上而下贯穿整棵树找出包含目标点所在的叶子，并在这个球里找出与目标点最靠近的点，这将确定出目标点距离它的最近邻点的一个上限值，然后跟KD树查找一样，检查同胞结点，如果目标点到同胞结点中心的距离超过同胞结点的半径与当前的上限值之和，那么同胞结点里不可能存在一个更近的点；否则的话，必须进一步检查位于同胞结点以下的子树。\r\n\r\n    如下图，目标点还是用一个星表示，黑色点是当前已知的的目标点的最近邻，灰色球里的所有内容将被排除，因为灰色球的中心点离的太远，所以它不可能包含一个更近的点，像这样，递归的向树的根结点进行回溯处理，检查所有可能包含一个更近于当前上限值的点的球。\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155378016798209104.jpg'\/>\r\n\r\n 球树是自上而下的建立，和KD树一样，根本问题就是要找到一个好的方法将包含数据点集的球分裂成两个，在实践中，不必等到叶子结点只有两个胡数据点时才停止，可以采用和KD树一样的方法，一旦结点上的数据点打到预先设置的最小数量时，便可提前停止建树过程。\r\n\r\n    也就是上面所述，先从球中选择一个离球的中心最远的点，然后选择第二个点离第一个点最远，将球中所有的点分配到离这两个聚类中心最近的一个上，然后计算每个聚类的中心，以及聚类能够包含它所有数据点所需的最小半径。这种方法的优点是分裂一个包含n个殊绝点的球的成本只是随n呈线性增加(注：本小节内容主要来自参考条目19：数据挖掘实用机器学习技术，[新西兰]Ian H.Witten 著，第4章4.7节)。\r\n\r\n2.7.2、VP树与MVP树简介\r\n\r\n    高维特征向量的距离索引问题是基于内容的图像检索的一项关键技术，目前经常采用的解决办法是首先对高维特征空间做降维处理，然后采用包括四叉树、kd树、R树族等在内的主流多维索引结构，这种方法的出发点是：目前的主流多维索引结构在处理维数较低的情况时具有比较好的效率，但对于维数很高的情况则显得力不从心(即所谓的维数危机) 。\r\n\r\n    实验结果表明当特征空间的维数超过20 的时候，效率明显降低，而可视化特征往往采用高维向量描述，一般情况下可以达到10^2的量级，甚至更高。在表示图像可视化特征的高维向量中各维信息的重要程度是不同的，通过降维技术去除属于次要信息的特征向量以及相关性较强的特征向量，从而降低特征空间的维数，这种方法已经得到了一些实际应用。\r\n\r\n    然而这种方法存在不足之处采用降维技术可能会导致有效信息的损失，尤其不适合于处理特征空间中的特征向量相关性很小的情况。另外主流的多维索引结构大都针对欧氏空间，设计需要利用到欧氏空间的几何性质，而图像的相似性计算很可能不限于基于欧氏距离。这种情况下人们越来越关注基于距离的度量空间高维索引结构可以直接应用于高维向量相似性查询问题。\r\n\r\n    度量空间中对象之间的距离度量只能利用三角不等式性质，而不能利用其他几何性质。向量空间可以看作由实数坐标串组成的特殊度量空间，目前针对度量空间的高维索引问题提出的索引结构有很多种大致可以作如下分类，如下图所示：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155378019794521032.jpg'\/>\r\n  其中，VP树和MVP树中特征向量的举例表示为：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155378021775105215.jpg'\/>\r\n 读者点评：\r\n\r\nUESTC_HN_AY_GUOBO：现在主要是在kdtree的基础上有了mtree或者mvptree，其实关键还是pivot的选择，以及度量空间中算法怎么减少距离计算；\r\nmandycool：mvp-tree，是利用三角形不等式来缩小搜索区域的，不过mvp-tree的目标稍有不同，查询的是到query点的距离小于某个值r的点；另外作者test的数据集只有20维，不知道上百维以后效果如何，而减少距离计算的一个思路是做embedding，通过不等式排除掉一部分点。\r\n    更多内容请参见论文1：DIST ANCE-BASED INDEXING FOR HIGH-DIMENSIONAL METRIC SP ACES，作者：Tolga Bozkaya & Meral Ozsoyoglu，及论文2：基于度量空间高维索引结构VP-tree及MVP-tree的图像检索，王志强，甘国辉，程起敏。\r\n\r\n    当然，如果你觉得上述论文还不够满足你胃口的话，这里有一大堆nearest neighbor algorithms相关的论文可供你看：http:\/\/scholar.google.com.hk\/scholar?q=nearest+neighbor+algorithms&btnG=&hl=zh-CN&as_sdt=0&as_vis=1（其中，这篇可以看下：Spill-Trees，An investigation of practical approximate nearest neighbor algorithms）。\r\n\r\n第三部分、KD树的应用：SIFT+KD_BBF搜索算法\r\n\r\n3.1、SIFT特征匹配算法    \r\n\r\n    之前本blog内阐述过图像特征匹配SIFT算法，写过五篇文章，这五篇文章分别为：\r\n\r\n九、图像特征提取与匹配之SIFT算法      (sift算法系列五篇文章)\r\n九（续）、sift算法的编译与实现\r\n九（再续）、教你一步一步用c语言实现sift算法、上\r\n九（再续）、教你一步一步用c语言实现sift算法、下\r\n九（三续）：SIFT算法的应用--目标识别之Bag-of-words模型\r\n    不熟悉SIFT算法相关概念的可以看上述几篇文章，这里不再做赘述。与此同时，本文此部分也作为十五个经典算法研究系列里SIFT算法的九之四续。\r\n\r\n    OK，我们知道，在sift算法中，给定两幅图片图片，若要做特征匹配，一般会先提取出图片中的下列相关属性作为特征点：\r\n\/**\r\nStructure to represent an affine invariant image feature.  The fields\r\nx, y, a, b, c represent the affine region around the feature:\r\na(x-u)(x-u) + 2b(x-u)(y-v) + c(y-v)(y-v) = 1\r\n*\/\r\nstruct feature\r\n{\r\n\tdouble x;                      \/**< x coord *\/\r\n\tdouble y;                      \/**< y coord *\/\r\n\tdouble a;                      \/**< Oxford-type affine region parameter *\/\r\n\tdouble b;                      \/**< Oxford-type affine region parameter *\/\r\n\tdouble c;                      \/**< Oxford-type affine region parameter *\/\r\n\tdouble scl;                    \/**< scale of a Lowe-style feature *\/\r\n\tdouble ori;                    \/**< orientation of a Lowe-style feature *\/\r\n\tint d;                         \/**< descriptor length *\/\r\n\tdouble descr[FEATURE_MAX_D];   \/**< descriptor *\/\r\n\tint type;                      \/**< feature type, OXFD or LOWE *\/\r\n\tint category;                  \/**< all-purpose feature category *\/\r\n\tstruct feature* fwd_match;     \/**< matching feature from forward image *\/\r\n\tstruct feature* bck_match;     \/**< matching feature from backmward image *\/\r\n\tstruct feature* mdl_match;     \/**< matching feature from model *\/\r\n\tCvPoint2D64f img_pt;           \/**< location in image *\/\r\n\tCvPoint2D64f mdl_pt;           \/**< location in model *\/\r\n\tvoid* feature_data;            \/**< user-definable data *\/\r\n\tchar dense;\t\t\t\t\t\t\/*表征特征点所处稠密程度*\/\r\n}
{"quesInfo":{"id":3010,"ques":"模拟退火算法能解决陷入局部最优的问题么","analysis":"本题解析来源：https:\/\/www.cnblogs.com\/ranjiewen\/p\/6084052.html\r\n\r\n著名的模拟退火算法，它是一种基于蒙特卡洛思想设计的近似求解最优化问题的方法。\r\n\r\n一点历史——如果你不感兴趣，可以跳过\r\n     美国物理学家 N.Metropolis 和同仁在1953年发表研究复杂系统、计算其中能量分布的文章，他们使用蒙特卡罗模拟法计算多分子系统中分子的能量分布。这相当于是本文所探讨之问题的开始，事实上，模拟退火中常常被提到的一个名词就是Metropolis准则，后面我们还会介绍。\r\n\r\n美国IBM公司物理学家 S.Kirkpatrick、C. D. Gelatt 和 M. P. Vecchi 于1983年在《Science》上发表了一篇颇具影响力的文章：《以模拟退火法进行最优化（Optimization by Simulated Annealing）》。他们借用了Metropolis等人的方法探讨一种旋转玻璃态系统（spin glass system）时，发觉其物理系统的能量和一些组合最优（combinatorial optimization）问题（著名的旅行推销员问题TSP即是一个代表例子）的成本函数相当类似：寻求最低成本即似寻求最低能量。由此，他们发展出以 Metropolis  方法为本的一套算法，并用其来解决组合问题等的寻求最优解。\r\n\r\n几乎同时，欧洲物理学家 V.Carny 也发表了几乎相同的成果，但两者是各自独立发现的；只是Carny“运气不佳”，当时没什么人注意到他的大作；或许可以说，《Science》杂志行销全球，“曝光度”很高，素负盛名，而Carny却在另外一本发行量很小的专门学术期刊《J.Opt.Theory Appl.》发表其成果因而并未引起应有的关注。\r\n\r\nKirkpatrick等人受到Metropolis等人用蒙特卡罗模拟的启发而发明了“模拟退火”这个名词，因为它和物体退火过程相类似。寻找问题的最优解（最值）即类似寻找系统的最低能量。因此系统降温时，能量也逐渐下降，而同样意义地，问题的解也“下降”到最值。\r\n \r\n一、什么是退火——物理上的由来\r\n在热力学上，退火（annealing）现象指物体逐渐降温的物理现象，温度愈低，物体的能量状态会低；够低后，液体开始冷凝与结晶，在结晶状态时，系统的能量状态最低。大自然在缓慢降温（亦即，退火）时，可“找到”最低能量状态：结晶。但是，如果过程过急过快，快速降温（亦称「淬炼」，quenching）时，会导致不是最低能态的非晶形。\r\n\r\n如下图所示，首先（左图）物体处于非晶体状态。我们将固体加温至充分高（中图），再让其徐徐冷却，也就退火（右图）。加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小（此时物体以晶体形态呈现）。\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64157214872996458214.png'\/>\r\n似乎，大自然知道慢工出细活：缓缓降温，使得物体分子在每一温度时，能够有足够时间找到安顿位置，则逐渐地，到最后可得到最低能态，系统最安稳。\r\n\r\n二、模拟退火（Simulate Anneal）\r\n如果你对退火的物理意义还是晕晕的，没关系我们还有更为简单的理解方式。想象一下如果我们现在有下面这样一个函数，现在想求函数的（全局）最优解。如果采用Greedy策略，那么从A点开始试探，如果函数值继续减少，那么试探过程就会继续。而当到达点B时，显然我们的探求过程就结束了（因为无论朝哪个方向努力，结果只会越来越大）。最终我们只能找打一个局部最后解B。\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64157214878099078900.png'\/>\r\n模拟退火其实也是一种Greedy算法，但是它的搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。以上图为例，模拟退火算法在搜索到局部最优解B后，会以一定的概率接受向右继续移动。也许经过几次这样的不是局部最优的移动后会到达B 和C之间的峰点，于是就跳出了局部最小值B。\r\n\r\n根据Metropolis准则，粒子在温度T时趋于平衡的概率为exp(-ΔE\/(kT))，其中E为温度T时的内能，ΔE为其改变数,k为Boltzmann常数。Metropolis准则常表示为\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64157214879115513684.png'\/>\r\n\r\n\r\nMetropolis准则表明，在温度为T时，出现能量差为dE的降温的概率为P(dE)，表示为：P(dE) = exp( dE\/(kT) )。其中k是一个常数，exp表示自然指数，且dE < 0。所以P和T正相关。这条公式就表示：温度越高，出现一次能量差为dE的降温的概率就越大；温度越低，则出现降温的概率就越小。又由于dE总是小于0（因为退火的过程是温度逐渐下降的过程），因此dE\/kT < 0 ，所以P(dE)的函数取值范围是(0,1) 。随着温度T的降低，P(dE)会逐渐降低。\r\n\r\n我们将一次向较差解的移动看做一次温度跳变过程，我们以概率P(dE)来接受这样的移动。也就是说，在用固体退火模拟组合优化问题，将内能E模拟为目标函数值 f，温度T演化成控制参数 t，即得到解组合优化问题的模拟退火演算法：由初始解 i 和控制参数初值 t 开始，对当前解重复“产生新解→计算目标函数差→接受或丢弃”的迭代，并逐步衰减 t 值，算法终止时的当前解即为所得近似最优解，这是基于蒙特卡罗迭代求解法的一种启发式随机搜索过程。退火过程由冷却进度表(Cooling Schedule)控制，包括控制参数的初值 t 及其衰减因子Δt 、每个 t 值时的迭代次数L和停止条件S。\r\n\r\n总结起来就是：\r\n若f( Y(i+1) ) < = f( Y(i) )  (即移动后得到更优解)，则总是接受该移动；\r\n若f( Y(i+1) ) > f( Y(i) )  (即移动后的解比当前解要差)，则以一定的概率接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定）。相当于上图中，从B移向BC之间的小波峰时，每次右移（即接受一个更糟糕值）的概率在逐渐降低。如果这个坡特别长，那么很有可能最终我们并不会翻过这个坡。如果它不太长，这很有可能会翻过它，这取决于衰减 t 值的设定。\r\n \r\n关于普通Greedy算法与模拟退火，有一个有趣的比喻：\r\n普通Greedy算法：兔子朝着比现在低的地方跳去。它找到了不远处的最低的山谷。但是这座山谷不一定最低的。这就是普通Greedy算法，它不能保证局部最优值就是全局最优值。\r\n模拟退火：兔子喝醉了。它随机地跳了很长时间。这期间，它可能走向低处，也可能踏入平地。但是，它渐渐清醒了并朝最低的方向跳去。这就是模拟退火。\r\n\r\n通过一个实例来编程演示模拟退火的执行。特别地，我们这里所采用的实例是著名的“旅行商问题”（TSP，Traveling Salesman Problem），它是哈密尔顿回路的一个实例化问题，也是最早被提出的NP问题之一。\r\nTSP是一个最常被用来解释模拟退火用法的问题，因为这个问题比较有名，我们这里不赘言重述，下面直接给出C++实现的代码：\r\n#include \r\n#include \r\n#include \r\n#include \r\n#include \r\n#include \r\n#include \r\n\r\n#define N     30      \/\/城市数量\r\n#define T     3000    \/\/初始温度\r\n#define EPS   1e-8    \/\/终止温度\r\n#define DELTA 0.98    \/\/温度衰减率\r\n\r\n#define LIMIT 1000   \/\/概率选择上限\r\n#define OLOOP 20    \/\/外循环次数\r\n#define ILOOP 100   \/\/内循环次数\r\n\r\nusing namespace std;\r\n\r\n\/\/定义路线结构体\r\nstruct Path\r\n{\r\n    int citys[N];\r\n    double len;\r\n}
{"quesInfo":{"id":2081,"ques":"音乐播放器的随机播放","analysis":"题目描述\r\n假设张三的mp3里有1000首歌，现在希望设计一种随机算法来随机播放。与普通随机模式不同的是，张三希望每首歌被随机到的概率是与一首歌的豆瓣评分（0~10分）成正比的，如朴树的《平凡之路》评分为8.9分，逃跑计划的《夜空中最亮的星》评分为9.5分，则希望听《平凡之路》的概率与《夜空中最亮的星》的概率比为89:95。\r\n\r\n现在我们已知这1000首歌的豆瓣评分：\r\n（1）请设计一种随机算法来满足张三的需求。\r\n（2）写代码实现自己的算法。\r\n\r\n\r\n分析与解法\r\n#include <iostream>\r\n#include <time.h>\r\n#include <stdlib.h>\r\nusing namespace std;\r\n  \r\nint findIdx(double songs[],int n,double rnd){\r\n    int left=0;\r\n    int right=n-1;\r\n    int mid;\r\n    while(left<=right){\r\n        mid=(left+right)\/2;\r\n        if((songs[mid-1]<=rnd) && (songs[mid]>=rnd))\r\n            return mid;\r\n        if(songs[mid]>rnd)\r\n            right=mid-1;\r\n        else\r\n            left=mid+1;\r\n    }\r\n\/\/    return mid;\r\n}\r\n  \r\nint randomPlaySong(double sum_scores[],int n){\r\n    double mx=sum_scores[n-1];\r\n    double rnd= rand()*mx\/(double)(RAND_MAX);\r\n    return findIdx(sum_scores,n,rnd);\r\n}\r\n  \r\nint main()\r\n{\r\n    srand(time(0));\r\n    double scores[]={5.5,6.5,4.5,8.5,9.5,7.5,3.5,5.0,8.0,2.0}
{"quesInfo":{"id":2767,"ques":"字符串包含","analysis":"题目描述\r\n给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？\r\n\r\n为了简单起见，我们规定输入的字符串只包含大写英文字母，请实现函数bool StringContains(string &A, string &B)\r\n\r\n比如，如果是下面两个字符串：\r\nString 1：ABCD\r\nString 2：BAD\r\n答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。\r\n\r\n如果是下面两个字符串：\r\nString 1：ABCD\r\nString 2：BCE\r\n答案是false，因为字符串String2里的E字母不在字符串String1里。\r\n\r\n同时，如果string1：ABCD，string 2：AA，同样返回true。\r\n\r\n\r\n分析与解法\r\n题目描述虽长，但题意很明了，就是给定一长一短的两个字符串A，B，假设A长B短，要求判断B是否包含在字符串A中。\r\n\r\n初看似乎简单，但实现起来并不轻松，且如果面试官步步紧逼，一个一个否决你能想到的方法，要你给出更好、最好的方案时，恐怕就要伤不少脑筋了。\r\n\r\n解法一\r\n\r\n判断string2中的字符是否在string1中?最直观也是最简单的思路是，针对string2中每一个字符，逐个与string1中每个字符比较，看它是否在String1中。\r\n\r\n代码可如下编写：\r\n\r\nbool StringContain(string &a,string &b)\r\n{\r\n    for (int i = 0; i < b.length(); ++i) {\r\n        int j;\r\n        for (j = 0; (j < a.length()) && (a[j] != b[i]); ++j)\r\n            ;\r\n        if (j >= a.length())\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n假设n是字符串String1的长度，m是字符串String2的长度，那么此算法，需要O(n*m)次操作。显然，时间开销太大，应该找到一种更好的办法。\r\n\r\n解法二\r\n\r\n如果允许排序的话，我们可以考虑下排序。比如可先对这两个字符串的字母进行排序，然后再同时对两个字串依次轮询。两个字串的排序需要(常规情况)O(m log m) + O(n log n)次操作，之后的线性扫描需要O(m+n)次操作。\r\n\r\n关于排序方法，可采用最常用的快速排序，参考代码如下：\r\n\r\n\/\/注意A B中可能包含重复字符，所以注意A下标不要轻易移动。这种方法改变了字符串。如不想改变请自己复制\r\nbool StringContain(string &a,string &b)\r\n{\r\n    sort(a.begin(),a.end());\r\n    sort(b.begin(),b.end());\r\n    for (int pa = 0, pb = 0; pb < b.length();)\r\n    {\r\n        while ((pa < a.length()) && (a[pa] < b[pb]))\r\n        {\r\n            ++pa;\r\n        }\r\n        if ((pa >= a.length()) || (a[pa] > b[pb]))\r\n        {\r\n            return false;\r\n        }\r\n        \/\/a[pa] == b[pb]\r\n        ++pb;\r\n    }\r\n    return true;\r\n}\r\n解法三\r\n\r\n有没有比快速排序更好的方法呢？\r\n\r\n我们换一种角度思考本问题：\r\n\r\n假设有一个仅由字母组成字串，让每个字母与一个素数对应，从2开始，往后类推，A对应2，B对应3，C对应5，......。遍历第一个字串，把每个字母对应素数相乘。最终会得到一个整数。\r\n\r\n利用上面字母和素数的对应关系，对应第二个字符串中的字母，然后轮询，用每个字母对应的素数除前面得到的整数。如果结果有余数，说明结果为false。如果整个过程中没有余数，则说明第二个字符串是第一个的子集了（判断是不是真子集，可以比较两个字符串对应的素数乘积，若相等则不是真子集）。\r\n\r\n思路总结如下：\r\n\r\n按照从小到大的顺序，用26个素数分别与字符'A'到'Z'一一对应。\r\n遍历长字符串，求得每个字符对应素数的乘积。\r\n遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除。\r\n输出结果。\r\n如前所述，算法的时间复杂度为O(m+n)的最好的情况为O(n)（遍历短的字符串的第一个数，与长字符串素数的乘积相除，即出现余数，便可退出程序，返回false），n为长字串的长度，空间复杂度为O(1)。\r\n\r\n\/\/此方法只有理论意义，因为整数乘积很大，有溢出风险\r\nbool StringContain(string &a,string &b)\r\n{\r\n    const int p[26] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,61, 67, 71, 73, 79, 83, 89, 97, 101}
{"quesInfo":{"id":2771,"ques":"无重复字符的最长子串","analysis":"题目描述\r\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\r\n示例 1:\r\n输入: \"abcabcbb\"\r\n输出: 3 \r\n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\r\n\r\n示例 2:\r\n输入: \"bbbbb\"\r\n输出: 1\r\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\r\n\r\n示例 3:\r\n输入: \"pwwkew\"\r\n输出: 3\r\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\r\n\r\n请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串（子串必须连续，子序列则不要求连续）。\r\n\r\n\r\n分析与解法\r\n首先想到的解决思路是先遍历整个字符串，然后对遍历到的每个字符后的字符做处理（检查是否有重复元素），我们通过建立一个空的字符串，如果检查的字符在这个空的字符串中没有的话，我们将他加入这个空字符串中，并且记录这个空字符串的长度。\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: int\r\n        \"\"\"\r\n        maxLength = 0\r\n        for i,_ in enumerate(s):  #这里没有使用range函数      \r\n            count = 0\r\n            usedChar = str()\r\n            for j in s[i:]: \r\n                if j not in usedChar:\r\n                    usedChar += j\r\n                    count += 1\r\n                    if maxLength < count:#这里没有使用max函数\r\n                        maxLength = count\r\n                else:                   \r\n\r\n上述代码中我没有使用注释中的做法，是因为那样做消耗的时间会增加很多（尤其这里如果使用max函数操作会极大地增加时间消耗，但是有的时候使用max函数速度会更快，暂时不清楚原因），大家可以自己测试一下。\r\n\r\n另外，我们通过分析可以知道这个算法最差情况的时间复杂度是O(n^2)级别的，这显然不是我们想看到的。我们分析一下这个算法的缺陷在哪？\r\np w w k e w\r\ni\r\n    j\r\nusedChar = pw\r\n当j移动到第二个w时，这个时候j in usedChar，那么我们跳出循环。接着\r\n\r\np w w k e w\r\n  i\r\n    j\r\nusedChar = w \r\n这个步骤其实是没有用的，因为去掉一个元素后，不可能比之前的元素更长了。我们可以直接跳到重复元素之后开始新的循环。\r\n\r\np w w k e w\r\n    i\r\n    j\r\nusedChar = w \r\n\r\n我们这里借用「两数之和中使用hash表」的思想\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: int\r\n        \"\"\"\r\n        start = maxLength = 0\r\n        usedChar = {}\r\n        for index, char in enumerate(s):\r\n            if char in usedChar and start <= usedChar[char]:\r\n                start = usedChar[char] + 1\r\n            else:\r\n                maxLength = max(maxLength, index - start + 1)\r\n            usedChar[char] = index\r\n        return maxLength\r\n这种解法速度很快，时间复杂度是O(n)级别，但是空间复杂度也是O(n)级别。这也是我认为这个题目目前为止最精彩的回答！\r\n\r\n当然这个问题，我们也可以使用Leetcode 209:长度最小的子数组中提到的滑动窗口思想。\r\nclass Solution:\r\n    \"\"\"\r\n    :type s: str\r\n    :rtype: int\r\n    \"\"\"\r\n    def lengthOfLongestSubstring(self, s):\r\n        l = 0\r\n        r = 0\r\n        maxLength = 0\r\n        s_len = len(s)\r\n        usedChar = [0] * 256 #通过符号表记录符号出现次数\r\n        while l < s_len:\r\n            if r < s_len and usedChar[ord(s[r])] == 0:\r\n                usedChar[ord(s[r])] += 1\r\n                r += 1\r\n            else:\r\n                usedChar[ord(s[l])] -= 1\r\n                l += 1\r\n\r\n            maxLength = max(maxLength, r - l)\r\n        return maxLength\r\n\r\n这个解法虽然比前面的慢，但是空间复杂度是O(256)级别，而时间复杂度同样是O(n)级别。\r\n\r\n最后补充一个C++的版本\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) \r\n    {\r\n        int l = 0;\r\n        int r = 0;\r\n        int maxLength = 0;\r\n        int usedChar[256] = { 0 }
{"quesInfo":{"id":2774,"ques":"通配符匹配","analysis":"题目描述\r\n给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。\r\n\r\n'?' 可以匹配任何单个字符。\r\n'*' 可以匹配任意字符串（包括空字符串）。\r\n两个字符串完全匹配才算匹配成功。\r\n\r\n说明:\r\ns 可能为空，且只包含从 a-z 的小写字母。\r\np 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。\r\n\r\n示例 1:\r\n输入:\r\ns = \"aa\"\r\np = \"a\"\r\n输出: false\r\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\r\n\r\n示例 2:\r\n输入:\r\ns = \"aa\"\r\np = \"*\"\r\n输出: true\r\n解释: '*' 可以匹配任意字符串。\r\n\r\n示例 3:\r\n输入:\r\ns = \"cb\"\r\np = \"?a\"\r\n输出: false\r\n解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。\r\n\r\n\r\n分析与解法\r\n解法一 暴力枚举\r\n看到题目我最先想到的是dfs暴力枚举所有情况，想想也知道会TLE，不出所料。感觉自己真是low爆了！\r\n\r\n\r\n解法二 动态规划\r\n接着往下想，会考虑到使用动态规划，想想字符串的编辑距离问题，那么这个题目的动态转移方程应该也是类似推导出来的。\r\n\r\n不妨令dp[i][j]表示s(0,i)的子串是否与p(0,j)的子串完全匹配，那么我们来看看dp[i][j]与dp[i-1][j], dp[i][j-1], dp[i-1][j-1]的关系。\r\n\r\n例如：s = \"aab\", p = \"a?*b\", 那么可得出如下表格：\r\n可以发现dp[i][j]为真有三种情况：\r\n(1) dp[i-1][j-1]为真，且s[i] 与 s[j]匹配；\r\n(2) dp[i-1][j]为真，且p[j]为'*'，此时用'*'匹配多个字符\r\n(3) dp[i][j-1]为真，且p[j]为'*'，此时'*'匹配空字符。\r\n故有：dp[i][j] = ((dp[i-1][j-1] && equal(s+i,p+j)) ||  (dp[i-1][j] && (*(p+j)=='*')) || (dp[i][j-1] && (*(p+j)=='*')));\r\n\r\n此处为了方便，我将dp[0][0~n]与dp[0~m][0]初始化为空字符串与p的匹配情况和s与空字符串的匹配情况，具体代码如下：\r\nclass Solution {\r\npublic:\r\n    \/**\r\n     * @param s: A string \r\n     * @param p: A string includes \"?\" and \"*\"\r\n     * @return: A boolean\r\n     *\/\r\n    bool equal(const char *s, const char *p){\r\n        if(*s == *p) return true;\r\n        if(*p == '?' || *p == '*')   return true;\r\n        return false;\r\n    }\r\n     \r\n    bool isMatch(const char *s, const char *p) {\r\n        \/\/ write your code here\r\n        if(s == NULL && p == NULL)   return true;\r\n        int m = strlen(s);\r\n        int n = strlen(p);\r\n        if(m == 0 && n == 0)   return true;\r\n        vector<bool> tmp(n+1,false);\r\n        vector<vector<bool> > dp(m+1,tmp);\r\n        dp[0][0] = true;\r\n        for(int i=0; i<n; ++i){\r\n            dp[0][i+1] = (dp[0][i] && (*(p+i) == '*'));\r\n        }\r\n        for(int i=0; i<m; ++i){\r\n            for(int j=0; j<n; ++j){\r\n                dp[i+1][j+1] = ((dp[i][j] && equal(s+i,p+j)) || (dp[i][j+1] && (*(p+j)=='*')) || (dp[i+1][j] && (*(p+j)=='*')));\r\n                \/\/printf(\"dp[%d][%d]=%d \",i+1,j+1,dp[i+1][j+1]?1:0);\r\n            }\r\n            \/\/printf(\"\\n\");\r\n        }\r\n        return dp[m][n];\r\n    }\r\n}
{"quesInfo":{"id":2775,"ques":"翻转字符串里的单词","analysis":"题目描述\r\n给定一个字符串，逐个翻转字符串中的每个单词。\r\n\r\n示例:  \r\n输入: \"the sky is blue\",\r\n输出: \"blue is sky the\".\r\n\r\n说明:\r\n无空格字符构成一个单词。\r\n输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\r\n如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\r\n进阶: 请选用C语言的用户尝试使用 O(1) 空间复杂度的原地解法。\r\n\r\n\r\n分析与解法\r\n解法一\r\n这道题让我们翻转字符串中的单词，题目中给了我们写特别说明，如果单词之间遇到多个空格，只能返回一个，而且首尾不能有单词，并且对C语言程序员要求空间复杂度为O(1)，所以我们只能对原字符串s之间做修改，而不能声明新的字符串。\r\n\r\n那么我们如何翻转字符串中的单词呢，我们的做法是，先整个字符串整体翻转一次，然后再分别翻转每一个单词（或者先分别翻转每一个单词，然后再整个字符串整体翻转一次），此时就能得到我们需要的结果了。\r\n\r\n这里我们需要定义一些变量来辅助我们解题，storeIndex表示当前存储到的位置，n为字符串的长度。我们先给整个字符串反转一下，然后我们开始循环，遇到空格直接跳过，如果是非空格字符，我们此时看storeIndex是否为0，为0的话表示第一个单词，不用增加空格；如果不为0，说明不是第一个单词，需要在单词中间加一个空格，然后我们要找到下一个单词的结束位置我们用一个while循环来找下一个为空格的位置，在此过程中继续覆盖原字符串，找到结束位置了，下面就来翻转这个单词，然后更新i为结尾位置，最后遍历结束，我们剪裁原字符串到storeIndex位置，就可以得到我们需要的结果。\r\n\r\n代码如下：\r\nclass Solution {\r\npublic:\r\n    void reverseWords(string &s) {\r\n        int storeIndex = 0, n = s.size();\r\n        reverse(s.begin(), s.end());\r\n        for (int i = 0; i < n; ++i) {\r\n            if (s[i] != ' ') {\r\n                if (storeIndex != 0) s[storeIndex++] = ' ';\r\n                int j = i;\r\n                while (j < n && s[j] != ' ') s[storeIndex++] = s[j++];\r\n                reverse(s.begin() + storeIndex - (j - i), s.begin() + storeIndex);\r\n                i = j;\r\n            }\r\n        }\r\n        s.resize(storeIndex);\r\n    }\r\n}
{"quesInfo":{"id":2777,"ques":"根据二叉树创建字符串","analysis":"题目描述\r\n你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。\r\n\r\n空节点则用一对空括号 \"()\" 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。\r\n\r\n示例 1:\r\n输入: 二叉树: [1,2,3,4]\r\n       1\r\n     \/   \\\r\n    2     3\r\n   \/    \r\n  4     \r\n输出: \"1(2(4))(3)\"\r\n解释: 原本将是“1(2(4)())(3())”，\r\n在你省略所有不必要的空括号对之后，\r\n它将是“1(2(4))(3)”。\r\n\r\n示例 2:\r\n输入: 二叉树: [1,2,3,null,4]\r\n       1\r\n     \/   \\\r\n    2     3\r\n     \\  \r\n      4 \r\n输出: \"1(2()(4))(3)\"\r\n解释: 和第一个示例相似，\r\n除了我们不能省略第一个对括号来中断输入和输出之间的一对一\r\n\r\n\r\n分析与解法\r\n解法一\r\n这道题给我们了一个二叉树，让我们创建对应的字符串，之前有一道正好反过来的题Construct Binary Tree from String。\r\n\r\n对于二叉树的处理，递归肯定是王道啊。想想如何来实现递归函数，我们观察到题目中的例子，发现如果左子结点为空，右子结点不为空时，需要在父结点后加上个空括号，而右子结点如果不存在，或者左右子结点都不存在就不需要这么做。\r\n\r\n那我们在递归函数中，如果当前结点不存在，直接返回，然后要在当前结点值前面加上左括号，然后判断，如果左子结点不存在，而右子结点存在的话，要在结果res后加上个空括号，然后分别对左右子结点调用递归函数，调用完之后要加上右括号，形成封闭的括号。由于最外面一层的括号不需要，所以我们再返回最终结果之前要去掉首尾的括号，参见代码如下：\r\nclass Solution {\r\npublic:\r\n    string tree2str(TreeNode* t) {\r\n        if (!t) return \"\";\r\n        string res = \"\";\r\n        helper(t, res);\r\n        return string(res.begin() + 1, res.end() - 1);\r\n    }\r\n    void helper(TreeNode* t, string& res) {\r\n        if (!t) return;\r\n        res += \"(\" + to_string(t->val);\r\n        if (!t->left && t->right) res += \"()\";\r\n        helper(t->left, res);\r\n        helper(t->right, res);\r\n        res += \")\";\r\n    }\r\n}
{"quesInfo":{"id":2779,"ques":"跳台阶问题","analysis":"题目描述\r\n一个台阶总共有n 级，如果一次可以跳1 级，也可以跳2 级。\r\n求总共有多少总跳法，并分析算法的时间复杂度。\r\n\r\n\r\n分析与解法\r\n解法一\r\n首先考虑最简单的情况。如果只有1级台阶，那显然只有一种跳法。如果有2级台阶，那就有两种跳的方法了：一种是分两次跳，每次跳1级；另外一种就是一次跳2级。\r\n\r\n现在我们再来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)。\r\n\r\n当n>2时，第一次跳的时候就有两种不同的选择：\r\n一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；\r\n另外一种选择是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。\r\n因此n级台阶时的不同跳法的总数f(n)=f(n-1)+f(n-2)。\r\n\r\n我们把上面的分析用一个公式总结如下：\r\n\r\n        \/  1                             n = 1\r\nf(n)=      2                             n = 2\r\n        \\  f(n-1) + f(n-2)               n > 2\r\n原来上述问题就是我们平常所熟知的Fibonacci数列问题。可编写代码，如下：\r\n\r\nlong long Fibonacci(unsigned int n)\r\n{\r\n    int result[3] = {0, 1, 2}
{"quesInfo":{"id":2785,"ques":"寻找两个有序数组的中位数","analysis":"题目描述\r\n给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。\r\n请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。\r\n\r\n你可以假设 nums1 和 nums2 不会同时为空。\r\n\r\n示例 1:\r\nnums1 = [1, 3]\r\nnums2 = [2]\r\n则中位数是 2.0\r\n\r\n示例 2:\r\nnums1 = [1, 2]\r\nnums2 = [3, 4]\r\n则中位数是 (2 + 3)\/2 = 2.5\r\n\r\n\r\n分析与解法\r\n题意非常简单，给定两个有序的数组，求中位数，难度系数给的是 Hard，希望的复杂度是 log 级别。回顾下中位数，对于一个有序数组，如果数组长度是奇数，那么中位数就是中间那个值，如果长度是偶数，就是中间两个数的平均数。\r\n\r\n解法一、O(nlogn)\r\n最容易想到的解法是 O(nlogn) 的解法，将两个数组合并成一个，然后排序，排序用 JavaScript 数组内置的 sort 函数，复杂度 nlogn，最后根据数组长度选择中位数，非常容易理解。\r\nvar findMedianSortedArrays = function(nums1, nums2) {\r\n  \/\/ 合并数组\r\n  var s = nums1.concat(nums2);\r\n\r\n  \/\/ 排序\r\n  s.sort(function(a, b) {\r\n    return a - b;\r\n  });\r\n\r\n  var len = s.length;\r\n\r\n  \/\/ 根据数组长度求中位数\r\n  if (len & 1) return s[~~(len \/ 2)];\r\n  else return (s[len \/ 2 - 1] + s[len \/ 2]) \/ 2;\r\n}
{"quesInfo":{"id":2787,"ques":"寻找和为定值的三个数","analysis":"题目描述\r\n给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。\r\n\r\n注意：答案中不可以包含重复的三元组。\r\n例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，\r\n满足要求的三元组集合为：\r\n[\r\n  [-1, 0, 1],\r\n  [-1, -1, 2]\r\n]\r\n\r\n\r\n分析与解法\r\n解法一\r\n三数之和为一定值，一般的方法是统计前两数之和，然后遍历第三个数，并且二分前面存和的数组。\r\n这里对于相同的元素不好处理，所以简单的第一想法是，平方遍历前两个数，二分第三个数。分析复杂度似乎也行。\r\n不过，在leetcode上提交时最后一个样例超时了。\r\n代码1：\r\nint threeSumMulti(vector<int>& A, int target) {\r\n    int sz = A.size();\r\n    int mod = 1e9+7;\r\n    sort(A.begin(),A.end());\r\n    long long sum = 0;\r\n    for(int i=0;i<sz;i++){\r\n        for(int j=0;j<i;j++){ \/\/枚举前两个数\r\n            int aa = target - A[i] - A[j];\r\n            int up = upper_bound(A.begin(),A.end(),aa) - A.begin()-1; \/\/二分第三个数，注意重复值\r\n            int low = lower_bound(A.begin(),A.end(),aa) - A.begin()-1;\r\n            int ma = max(low,i);\r\n            if(up>ma){\r\n                sum+=up-ma;\r\n                sum=sum%mod;\r\n            }\r\n        }\r\n    }\r\n    return sum;\r\n}\r\n\r\n\r\n解法二\r\n基于前一种思路，依旧遍历前两个值，不过因为前两个值确定了，我们可以记录下他们的和，以及用一个map来存储某一个和x有多少个。然后在以后的遍历过程中，遇到某一个值A[i]，在map中找到与其相对应的和的个数。使得A[I] + x ==target.\r\n\r\n代码2：\r\nint threeSumMulti(vector<int>& A, int target) {\r\n    unordered_map<int,int>ma;\r\n    int mod = 1e9+7;\r\n    int sz = A.size();\r\n    long long sum = 0;\r\n    for(int i=0;i<sz;i++){\r\n        sum = (sum+ma[target-A[i]])%mod;\r\n        for(int j=0;j<i;j++){\r\n            ++ma[A[i]+A[j]];\r\n        }\r\n    }\r\n    return sum%mod;\r\n}\r\n\r\n\r\n解法三\r\n观察一下，A[i]的取值范围只有100，而长度确有3000，也就是说，一个明显的提示就是去重。去重之后再用第一种二分的方法就行了，甚至三重循环也可。不过这不仅仅是简单的去重，我们得记录重复值个数。根据重复值个数我们可以算出在A[i],A[j],A[k]取相同值的时候的数量。\r\n\r\n代码3：\r\nclass Solution {\r\npublic:\r\nint threeSumMulti(vector<int>& A, int target) {\r\n    long long ch[105];\r\n    int mod = 1e9+7;\r\n    memset(ch,0,sizeof(ch));\r\n    for(int i=0;i<A.size();i++)ch[A[i]]++;\r\n    sort(A.begin(),A.end());\r\n    vector<int>::iterator index = unique(A.begin(),A.end());\r\n    A.erase(index,A.end());\r\n    int sz = A.size();\r\n    long long sum = 0;\r\n    for(int i=0;i<=100;i++){\r\n        for(int j=i;j<=100;j++){\r\n            int k = target - i-j;\r\n            if(k<i||k<j||k>100||ch[i]==0||ch[j]==0||ch[k]==0)continue;\r\n            if(i==j&&j==k){\r\n                if(ch[i]>=3)sum = (sum+(ch[i]*(ch[i]-1)*(ch[i]-2))\/6)%mod;\r\n            }\r\n            else if(i==j&&ch[i]>=2){\r\n                int ma = (ch[i]*(ch[i]-1)*ch[k])\/2;\r\n                sum = (sum+ma)%mod;\r\n\/\/                cout<<ma<<endl;\r\n            }\r\n            else if(k==i&&ch[k]>=2){\r\n                int ma = (ch[i]*(ch[i]-1)*ch[j])\/2;\r\n                sum = (sum+ma)%mod;\r\n            }\r\n            else if(k==j&&ch[k]>=2){\r\n                int ma = (ch[k]*(ch[k]-1)*ch[i])\/2;\r\n                sum = (sum+ma)%mod;\r\n            }\r\n            else if(i!=j&&j!=k&&i!=k){\r\n                sum = (sum+ch[i]*ch[j]*ch[k])%mod;\r\n            }\r\n            \/\/cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<sum<<endl;\r\n        }\r\n    }\r\n    return sum%mod;\r\n}\r\n}
{"quesInfo":{"id":2789,"ques":"螺旋矩阵的打印","analysis":"题目描述\r\nGiven a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order。一句话，即为螺旋矩阵问题。\r\n举个例子，给定如下的一个矩阵:\r\n[\r\n [ 1, 2, 3 ],\r\n [ 4, 5, 6 ],\r\n [ 7, 8, 9 ]\r\n]\r\n你应该返回：[1,2,3,6,9,8,7,4,5]。如下图所示，遍历顺序为螺旋状：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64154980192457416158.jpeg'\/>\r\n\r\n\r\n分析与解法\r\n如果只有一行或者一列，只要依次输出即可。\r\n如果多行多列，就依次向右，向下，向左，向上操作，从大圈到小圈；每转完一圈，行列各减少2；起点行列各加1。\r\n\r\n以下是一份参考代码：\r\n\/\/代码来源：http:\/\/discuss.leetcode.com\/questions\/29\/spiral-matrix。\r\nclass Solution {    \r\npublic:    \r\n\tvector<int> spiralOrder(vector<vector<int> >& matrix) {    \r\n\t\tvector<int> result;    \r\n\t\tif (matrix.empty()) return result;    \r\n\t\tssize_t beginX = 0, endX = matrix[0].size() - 1;    \r\n\t\tssize_t beginY = 0, endY = matrix.size() - 1;    \r\n \r\n\t\twhile (true) {    \r\n\t\t\t\/\/ From left to right    \r\n\t\t\tfor (ssize_t i = beginX; i <= endX; ++i)    \r\n\t\t\t\tresult.push_back(matrix[beginY][i]);    \r\n\t\t\tif (++beginY > endY) break;    \r\n \r\n\t\t\t\/\/ From top down    \r\n\t\t\tfor (ssize_t i = beginY; i <= endY; ++i)    \r\n\t\t\t\tresult.push_back(matrix[i][endX]);    \r\n\t\t\tif (beginX > --endX) break;    \r\n \r\n\t\t\t\/\/ From right to left    \r\n\t\t\tfor (ssize_t i = endX; i >= beginX; --i)    \r\n\t\t\t\tresult.push_back(matrix[endY][i]);    \r\n\t\t\tif (beginY > --endY) break;    \r\n \r\n\t\t\t\/\/ From bottom up    \r\n\t\t\tfor (ssize_t i = endY; i >= beginY; --i)    \r\n\t\t\t\tresult.push_back(matrix[i][beginX]);    \r\n\t\t\tif (++beginX > endX) break;    \r\n\t\t}    \r\n\t\treturn result;    \r\n\t}    \r\n}
{"quesInfo":{"id":2791,"ques":"跳台阶问题","analysis":"题目描述\r\n一个台阶总共有n 级，如果一次可以跳1 级，也可以跳2 级。求总共有多少总跳法，并分析算法的时间复杂度。\r\n\r\n\r\n分析与解法\r\n解法一\r\n首先考虑最简单的情况。如果只有1级台阶，那显然只有一种跳法。如果有2级台阶，那就有两种跳的方法了：一种是分两次跳，每次跳1级；另外一种就是一次跳2级。\r\n\r\n现在我们再来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)。\r\n\r\n当n>2时，第一次跳的时候就有两种不同的选择：\r\n一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；\r\n另外一种选择是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。\r\n因此n级台阶时的不同跳法的总数f(n)=f(n-1)+f(n-2)。\r\n\r\n我们把上面的分析用一个公式总结如下：\r\n\r\n        \/  1                             n = 1\r\nf(n)=      2                             n = 2\r\n        \\  f(n-1) + f(n-2)               n > 2\r\n原来上述问题就是我们平常所熟知的Fibonacci数列问题。可编写代码，如下：\r\n\r\nlong long Fibonacci(unsigned int n)\r\n{\r\n    int result[3] = {0, 1, 2}
{"quesInfo":{"id":2792,"ques":"合并两个有序数组","analysis":"题目描述\r\n给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。\r\n\r\n说明:\r\n初始化 nums1 和 nums2 的元素数量分别为 m 和 n。\r\n你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。\r\n\r\n示例:\r\n输入:\r\nnums1 = [1,2,3,0,0,0], m = 3\r\nnums2 = [2,5,6],       n = 3\r\n输出: [1,2,2,3,5,6]\r\n\r\n\r\n解法一\r\nclass Solution {\r\npublic:\r\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r\n        int num[m+n];\/\/新建一个数组，对nums1和nums2排序，排完序赋值给nums1\r\n        int i = 0,j = 0,k = 0;\r\n        while(i<m && j<n){\r\n            if(nums1[i] <= nums2[j])\r\n                num[k++] = nums1[i++];\r\n            else\r\n                num[k++] = nums2[j++];\r\n        }\r\n        while(i < m) num[k++] = nums1[i++];\r\n        while(j < n) num[k++] = nums2[j++];\r\n        copy(num,num+m+n,nums1.begin());\r\n    }\r\n}
{"quesInfo":{"id":2794,"ques":"杨辉三角","analysis":"题目描述\r\n给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64154986291639763038.gif'\/>\r\n在杨辉三角中，每个数是它左上方和右上方的数的和。\r\n\r\n\r\n解析\r\n杨辉三角是二项式系数的一种写法，具体生成计算是：每一行的首个和结尾一个数字都是1，从第三行开始，中间的每个数字都是上一行的左右两个数字之和。\r\n\r\n代码如下：\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> generate(int numRows) {\r\n        vector<vector<int>> res(numRows, vector<int>());\r\n        for (int i = 0; i < numRows; ++i) {\r\n            res[i].resize(i + 1, 1);\r\n            for (int j = 1; j < i; ++j) {\r\n                res[i][j] = res[i - 1][j - 1] + res[i - 1][j];\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}
{"quesInfo":{"id":2798,"ques":"找出数组中重复出现的数","analysis":"题目描述\r\n给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。\r\n找到所有出现两次的元素。\r\n你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？\r\n\r\n示例：\r\n输入:\r\n[4,3,2,7,8,2,3,1]\r\n输出:\r\n[2,3]\r\n\r\n\r\n分析与解法\r\n解法一、排序\r\n解决这个问题的一个简单的方法是先把输入的数组排序。从排序的数组中找出重复的数字是件容易的事情，只需要从头到尾扫描排序后的数组就可以了。排序一个长度为n的数组需要时间为O(nlogn)时间。\r\n\r\n\r\n解法二、哈希表\r\n还可以利用哈希表来解决这个问题，从头到尾按顺序扫描数组中的每个数，每扫描到一个数字的时候，都可以用O(1)的时间来判断哈希表里是否已经包含了该数字。如果哈希表里没有这个数字，就把它加入到哈希表里。如果哈希表里已经存在该数字了，那么就找到一个重复的数字。这个算法的时间复杂度为O(n)，但它提高时间效率是以一个大小为O(n)的哈希表为代价的。我们再看看有没有空间复杂度为O(1)的算法。\r\n\r\n\r\n解法三\r\n我们注意到数组中的数字都在0到n-1的范围内。如果这个数组中没有重复的数字，那么当数组排序后数字i将出现在下标为i的位置。由于数组中有重复的数字，有些位置可能存在多个数字，同时有些位置可能没有数字。\r\n\r\n现在让我们重排这个数组。从头到尾扫描这个数组中的每个数字。当扫描到下标为i的数字的时候，首先比较这个数字(用m表示）是不是i。如果是，接着扫描下一个数字。如果不是，再拿它和第m个数字进行比较。如果它和第m个数字相等，就找到一个重复的数字（该数字在下标为i和m的位置都出现了）。如果它和第m个数字不想等，就把第i个数字和第m个数字交换，把m放到属于它的位置。接下来再重复这个比较，交换的过程，直到发现一个重复的数字。\r\n\r\n以数组｛2，3，1，0，2，5，3｝为例来分析找到重复数字的步骤。\r\n数组的第0个数字（从0开始计数，和数组的下标保持一致）是2，与它的下标不相等，于是把它和下标为2的数字1交换，交换后的数组是｛1，3，2，0，2，5，3｝。\r\n此时第0 个数字是1，仍然与它的下标不相等，继续把它和下标为1的数字3交换，得到数组｛0，1，2，3，2，5，3｝。\r\n此时第0 个数字为0，接着扫描下一个数字，在接下来的几个数字中，下标为1，2，3的三个数字分别为1，2，3，他们的下标和数值都分别相等，因此不需要做任何操作。\r\n\r\n接下来扫描下标为4的数字2.由于它的值与它的下标不相等，再比较它和下标为2的数字。注意到此时数组中下标为2的数字也是2，也就是数字2和下标为2和下标4的两个位置都出现了，因此找到一个重复的数字。\r\n\r\n代码如下：\r\npublic class Solution {\r\n\r\n    public static int duplication;\r\n\r\n    public static boolean duplicate(int[] arr) {\r\n        if (arr == null || arr.length == 0) {\r\n            return false;\r\n        }\r\n\r\n        for (int i = 0; i < arr.length; i++) {\r\n            if (arr[i] < 0 || arr[i] >= arr.length) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < arr.length; i++) {\r\n            while (arr[i] != i) {\r\n                if (arr[i] == arr[arr[i]]) {\r\n                    duplication = arr[i];\r\n                    System.out.println(arr[i]);\r\n                    return true;\r\n                }\r\n\r\n                int temp = arr[i];\r\n                arr[i] = arr[temp];\r\n                arr[temp] = temp;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        int[] arr = { 0, 3, 1, 4, 2, 5, 7 }
{"quesInfo":{"id":2800,"ques":"最长连续递增序列","analysis":"题目描述\r\n给定一个未经排序的整数数组，找到最长且连续的的递增序列。\r\n\r\n示例 1:\r\n输入: [1,3,5,4,7]\r\n输出: 3\r\n解释: 最长连续递增序列是 [1,3,5], 长度为3。\r\n尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 \r\n\r\n示例 2:\r\n输入: [2,2,2,2,2]\r\n输出: 1\r\n解释: 最长连续递增序列是 [2], 长度为1。\r\n注意：数组长度不会超过10000。\r\n\r\n\r\n分析与解法\r\n这道题让我们求一个数组的最长连续递增序列，由于有了连续这个条件，跟之前那道Number of Longest Increasing Subsequence比起来，其实难度就降低了很多。\r\n\r\n解法一\r\n我们可以使用一个计数器，如果遇到大的数字，计数器自增1；如果是一个小的数字，则计数器重置为1。我们用一个变量cur来表示前一个数字，初始化为整型最大值，当前遍历到的数字num就和cur比较就行了，每次用cnt来更新结果res。\r\n\r\n参见代码如下：\r\nclass Solution {\r\npublic:\r\n    int findLengthOfLCIS(vector<int>& nums) {\r\n        int res = 0, cnt = 0, cur = INT_MAX;\r\n        for (int num : nums) {\r\n            if (num > cur) ++cnt;\r\n            else cnt = 1;\r\n            res = max(res, cnt);\r\n            cur = num;\r\n        }\r\n        return res;\r\n    }\r\n}
{"quesInfo":{"id":2801,"ques":"岛屿的最大面积","analysis":"题目描述\r\n给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。\r\n找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)\r\n\r\n示例 1:\r\n[[0,0,1,0,0,0,0,1,0,0,0,0,0],\r\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\r\n [0,1,1,0,1,0,0,0,0,0,0,0,0],\r\n [0,1,0,0,1,1,0,0,1,0,1,0,0],\r\n [0,1,0,0,1,1,0,0,1,1,1,0,0],\r\n [0,0,0,0,0,0,0,0,0,0,1,0,0],\r\n [0,0,0,0,0,0,0,1,1,1,0,0,0],\r\n [0,0,0,0,0,0,0,1,1,0,0,0,0]]\r\n对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。\r\n\r\n示例 2:\r\n[[0,0,0,0,0,0,0,0]]\r\n对于上面这个给定的矩阵, 返回 0。\r\n注意: 给定的矩阵grid 的长度和宽度都不超过 50。\r\n\r\n\r\n分析与解法\r\n解法一\r\n这道题跟之前的那两道Number of Islands和Number of Distinct Islands是同一个类型的，只不过这次需要统计出每个岛的大小，再来更新结果res。\r\n\r\n先用递归来做，遍历grid，当遇到为1的点，我们调用递归函数，在递归函数中，我们首先判断i和j是否越界，还有grid[i][j]是否为1，我们没有用visited数组，而是直接修改了grid数组，遍历过的标记为-1。如果合法，那么cnt自增1，并且更新结果res，然后对其周围四个相邻位置分别调用递归函数即可。\r\n\r\n参见代码如下：\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> dirs<img  src='https:\/\/julyedu-img-public.oss-cn-beijing.aliyuncs.com\/Public\/Image\/Question\/0,-1},{-1,0},{0,1},{1,0'\/>;\r\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\r\n        int m = grid.size(), n = grid[0].size(), res = 0;\r\n        for (int i = 0; i < m; ++i) {\r\n            for (int j = 0; j < n; ++j) {\r\n                if (grid[i][j] != 1) continue;\r\n                int cnt = 0;\r\n                helper(grid, i, j, cnt, res);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    void helper(vector<vector<int>>& grid, int i, int j, int& cnt, int& res) {\r\n        int m = grid.size(), n = grid[0].size();\r\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] <= 0) return;\r\n        res = max(res, ++cnt);\r\n        grid[i][j] *= -1;\r\n        for (auto dir : dirs) {\r\n            helper(grid, i + dir[0], j + dir[1], cnt, res);\r\n        }\r\n    }\r\n}
{"quesInfo":{"id":2804,"ques":"出现次数超过一半的数字","analysis":"题目描述\r\n数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。\r\n\r\n\r\n分析与解法\r\n一个数组中有很多数，现在我们要找出其中那个出现次数超过总数一半的数字，怎么找呢？大凡当我们碰到某一个杂乱无序的东西时，我们人的内心本质期望是希望把它梳理成有序的。所以，我们得分两种情况来讨论，无序和有序。\r\n\r\n\r\n解法一\r\n如果无序，那么我们是不是可以先把数组中所有这些数字先进行排序（至于排序方法可选取最常用的快速排序）。排完序后，直接遍历，在遍历整个数组的同时统计每个数字的出现次数，然后把那个出现次数超过一半的数字直接输出，题目便解答完成了。总的时间复杂度为O(nlogn + n)。\r\n\r\n但如果是有序的数组呢，或者经过排序把无序的数组变成有序后的数组呢？是否在排完序O(nlogn)后，还需要再遍历一次整个数组？\r\n\r\n我们知道，既然是数组的话，那么我们可以根据数组索引支持直接定向到某一个数。我们发现，一个数字在数组中的出现次数超过了一半，那么在已排好序的数组索引的N\/2处（从零开始编号），就一定是这个数字。自此，我们只需要对整个数组排完序之后，然后直接输出数组中的第N\/2处的数字即可，这个数字即是整个数组中出现次数超过一半的数字，总的时间复杂度由于少了最后一次整个数组的遍历，缩小到O(n*logn)。\r\n\r\n然时间复杂度并无本质性的改变，我们需要找到一种更为有效的思路或方法。\r\n\r\n\r\n解法二\r\n既要缩小总的时间复杂度，那么可以用查找时间复杂度为O(1)的hash表，即以空间换时间。哈希表的键值（Key）为数组中的数字，值（Value）为该数字对应的次数。然后直接遍历整个hash表，找出每一个数字在对应的位置处出现的次数，输出那个出现次数超过一半的数字即可。\r\n\r\n\r\n解法三\r\nHash表需要O(n)的空间开销，且要设计hash函数，还有没有更好的办法呢？我们可以试着这么考虑，如果每次删除两个不同的数（不管是不是我们要查找的那个出现次数超过一半的数字），那么，在剩下的数中，我们要查找的数（出现次数超过一半）出现的次数仍然超过总数的一半。通过不断重复这个过程，不断排除掉其它的数，最终找到那个出现次数超过一半的数字。这个方法，免去了排序，也避免了空间O(n)的开销，总得说来，时间复杂度只有O(n)，空间复杂度为O(1)，貌似不失为最佳方法。\r\n\r\n举个简单的例子，如数组a[5] = {0, 1, 2, 1, 1}
{"quesInfo":{"id":2808,"ques":"合并两个有序链表","analysis":"题目描述\r\n将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \r\n如下图所示\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155006354953788148.png'\/>\r\n\r\n\r\n分析与解法\r\n解法一 暴力重排\r\n既然题目要求我们合并两个链表，那直接把L2链表连接到L1链表之后不就OK了么？哦，新的链表依然需要有序，那也简单嘛，对新的链表直接重排序即可，至于排序方法可以选取常用的快速排序。\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155006353168820479.png'\/>\r\n\r\n当然，这种方法最容易想到同时也最暴力，就是时间效率上不过关，快速排序的时间复杂度为NlogN，故重新排序的时间复杂度为O(m+n)log(m+n)，m和n分别是L1和L2链表的长度，我们需要另寻更高效的解决办法。\r\n\r\n解法二 双指针法\r\n本解法参考自：http:\/\/blog.bittiger.io\/post191\/\r\n定义头指针p1（指向L1头节点）、p2（指向L2头节点），和指向当前节点的curr指针。在往后合并两个链表对过程中，我们比较两个链表中p1和p2指向的节点的值，然后令curr指针一直指向较小值的节点。如下图：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155006169849345324.png'\/>\r\n\r\n第一步，p1指向的节点2，小于p2指向节点6，所以curr指向p1所指向的节点2，接下来，p1指向下一节点5，如下图：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155006173680656220.png'\/>\r\n\r\n第二步，p1指向的节点5，仍然小于p2指向的节点6，所以curr继续指向p1所指向的节点5，p1则继续向后移动，如下图：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155006184299300607.png'\/>\r\n\r\n第三步，p1指向的节点7，大于p2指向的节点6，curr指向p2当前指向的节点6（curr始终是谁小指谁），p2则向后移动，如下图：\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155006186784399742.png'\/>\r\n\r\n以此类推，直到p1或者p2指针移动到链表的末端，因为我们在每次比较中都选择较小的值，所以当p1或者p2中任何一个指针指向链表末端，代表另外一个没有还没到达末端的链表的后序的值都比已到达末端的链表中最大的值要大，所以只需要将后续的节点追加到新的链表后即可。\r\n\r\n代码如下\r\n<img  src='https:\/\/julyedu-img.oss-cn-beijing.aliyuncs.com\/quesbase64155006190591157627.png'\/>\r\n\r\n\r\n解法三 递归\r\nC++代码如下(已在leetcode上AC)\r\nclass Solution {\r\npublic:\r\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\r\n        if(l1 == NULL)\r\n            return l2;\r\n        if(l2 == NULL)\r\n            return l1;\r\n        if(l1->val < l2->val){\r\n            \/\/如果l1的当前节点更小，则先合并l1的当前节点\r\n            \/\/换言之，为确保合并之后依然递增，谁小则先合并谁\r\n            l1->next = mergeTwoLists(l1->next,l2);\r\n            return l1;\r\n        }\r\n        else{\r\n            \/\/如果l2的当前节点更小，则先合并l2的当前节点\r\n            l2->next = mergeTwoLists(l1,l2->next);\r\n            return l2;\r\n        }\r\n    \r\n    }\r\n}
{"quesInfo":{"id":2809,"ques":"旋转链表","analysis":"题目描述\r\n给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。\r\n\r\n示例 1:\r\n\r\n输入: 1->2->3->4->5->NULL, k = 2\r\n输出: 4->5->1->2->3->NULL\r\n解释:\r\n向右旋转 1 步: 5->1->2->3->4->NULL\r\n向右旋转 2 步: 4->5->1->2->3->NULL\r\n\r\n示例 2:\r\n输入: 0->1->2->NULL, k = 4\r\n输出: 2->0->1->NULL\r\n解释:\r\n向右旋转 1 步: 2->0->1->NULL\r\n向右旋转 2 步: 1->2->0->NULL\r\n向右旋转 3 步: 0->1->2->NULL\r\n向右旋转 4 步: 2->0->1->NULL\r\n\r\n\r\n分析与解法\r\n首先，如果head == None or head.next == None我们直接返回head就可以了。接着我们设置\r\npre \r\n 1 -> 2 -> 3 -> 4 -> 5 -> NULL\r\n count=1\r\n\r\n直到pre.next!=None我们退出循环，否则我们pre=pre.next、count++。\r\n                    pre \r\n 1 -> 2 -> 3 -> 4 -> 5 -> NULL\r\n count=5\r\n\r\n然后，我们将链表做成循环链表，只要pre.next=head即可。\r\n\r\n                    pre \r\n 1 -> 2 -> 3 -> 4 -> 5 \r\n |                   |\r\n ---------------------\r\n count=5\r\n\r\n接着我们设置一个指针q=pre，通过计算n=count-k%count，得到我们要向左移动多少距离（因为q=q.next是左旋操作）\r\n           q        pre \r\n 1 -> 2 -> 3 -> 4 -> 5 \r\n |                   |\r\n ---------------------\r\n count=5 k=2 n=3\r\n\r\n接着我们只要设置ret=q.next、q.next=None，然后返回ret即可。\r\n\r\n代码如下\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (head == nullptr || head->next == nullptr){\r\n            return head;\r\n        }\r\n        ListNode* pre = head;\r\n        int count = 1;\r\n        while (pre->next != nullptr){\r\n            ++count;\r\n            pre = pre->next;\r\n        }\r\n        \r\n        pre->next = head;\r\n        int n = count - k % count;\r\n        ListNode* q = pre;\r\n        while (n--)\r\n        {\r\n            q = q->next;\r\n        }\r\n        ListNode* ret = q->next;\r\n        q->next = nullptr;\r\n        return ret;\r\n    }\r\n}
{"quesInfo":{"id":2810,"ques":"删除链表的倒数第N个节点","analysis":"给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\r\n\r\n示例：\r\n给定一个链表: 1->2->3->4->5, 和 n = 2.\r\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\r\n\r\n说明：\r\n给定的 n 保证是有效的。\r\n\r\n进阶：\r\n你能尝试使用一趟扫描实现吗？\r\n\r\n\r\n分析与解法\r\n代码如下(已在LeetCode上AC)\r\nclass Solution {\r\npublic:\r\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\r\n        if (head->next == NULL)\r\n            return NULL;\r\n        \r\n        ListNode* fast = head;\/\/快指针\r\n        ListNode* slow = head;\/\/慢指针\r\n            \r\n        \/\/快指针提前移动n步\r\n        for (int i = 0; i < n; i++) {\r\n            fast = fast->next;\r\n        }\r\n        \r\n        \/\/如果快指针移动n步之后为空，说明链表本身长度为N，那按照题目要求，需要移除的倒数第N个节点即是头节点\r\n        if (fast == NULL) {\r\n            return head->next;\r\n        }\r\n            \r\n        \/\/同时移动快慢指针，直到快指针到链表末尾\r\n        while (fast->next != NULL) {\r\n            fast = fast->next;\r\n            slow = slow->next;\r\n        }\r\n        \r\n        \/\/因为快慢指针之间相隔N步，所以快指针到达末尾之后，则慢指针刚好指向倒数第N个节点\r\n        slow->next = slow->next->next;\r\n        return head;\r\n    }\r\n}
{"quesInfo":{"id":2811,"ques":" 删除排序链表中的重复元素","analysis":"题目描述\r\n给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。\r\n\r\n示例 1:\r\n输入: 1->1->2\r\n输出: 1->2\r\n\r\n示例 2:\r\n输入: 1->1->2->3->3\r\n输出: 1->2->3\r\n\r\n\r\n分析与解法\r\n先分析一下特殊情况，比如链表为空，则不存在元素重复的情况\r\nif head == None or head.next == None:\r\n    return head\r\n\r\n在往后遍历链表的过程中，如果pre和cur的val相同的话，则可以删除cur所指向的元素，pre.next = cur.next，然后cur = cur.next\r\npre cur\r\n1   1   2   3   \r\n删之后\r\npre    cur\r\n1        2   3\r\n\r\n代码如下(已在leetcode上AC)\r\nclass Solution \r\n{\r\npublic:\r\n    ListNode* deleteDuplicates(ListNode* head) \r\n    {\r\n        if (head == nullptr || head->next == nullptr){\r\n            return head;\r\n        }\r\n        ListNode* pre = nullptr;\r\n        ListNode* cur = head;\r\n        \r\n        while (cur != nullptr){\r\n            \/\/不断向后扫描遍历\r\n            pre = cur;\r\n            cur = cur->next;\r\n            while (cur != nullptr && cur->val == pre->val){\r\n                \/\/pre cur\r\n                \/\/1   1   2   3\r\n                \/\/pre    cur\r\n                \/\/1        2   3\r\n                pre->next = cur->next;\r\n                ListNode* delNode = cur;\r\n                cur = cur->next;\r\n                delete delNode;\r\n            }\r\n        }\r\n        return head;\r\n    }\r\n}
{"quesInfo":{"id":2814,"ques":"反转链表","analysis":"题目描述\r\n反转一个单链表。\r\n比如\r\n输入: 1->2->3->4->5->NULL\r\n输出: 5->4->3->2->1->NULL\r\n\r\n对应七月在线OJ第1489题：https:\/\/oj.julyedu.com\/problem.php?id=1489\r\n\r\n\r\n分析与解法\r\n很经典的问题，首先设置pre、cur、lat三个指针\r\npre   cur  lat\r\nnull   1 -> 2 -> 3 -> 4 -> 5 -> null\r\n\r\n接下来，执行下述两步：\r\n①cur.next = pre\r\npre   cur  lat\r\nnull <-1    2 -> 3 -> 4 -> 5 -> null\r\n\r\n②pre = cur，cur = lat，lat = lat.next\r\n      pre  cur  lat\r\nnull <-1    2 -> 3 -> 4 -> 5 -> null\r\n\r\n重复上述两步，直到lat=None\r\n                     pre  cur  lat\r\nnull <-1 <- 2 <- 3 <- 4    5 -> null\r\n\r\n最后cur.next = pre即可。\r\n\r\n代码如下（已在LeetCode上AC）\r\nclass Solution \r\n{\r\npublic:\r\n    ListNode* reverseList(ListNode* head) \r\n    {\r\n        \/\/pre   cur  lat\r\n        \/\/null   1 -> 2 -> 3 -> 4 -> 5 -> null\r\n        ListNode* pre = nullptr;\r\n        ListNode* cur = head;\r\n        \r\n        \/\/接下来开始循环执行以下两步\r\n        \/\/①cur.next = pre\r\n        \/\/pre   cur  lat\r\n        \/\/null <-1    2 -> 3 -> 4 -> 5 -> null\r\n        \r\n        \/\/②pre = cur，cur = lat，lat = lat.next\r\n        \/\/      pre  cur  lat\r\n        \/\/null <-1    2 -> 3 -> 4 -> 5 -> null\r\n        while (cur != nullptr)\r\n        {\r\n            ListNode* lat = cur->next;\r\n            cur->next = pre;\r\n            pre = cur;\r\n            cur = lat;\r\n        }\r\n        return pre;\r\n    }\r\n}
{"quesInfo":{"id":2816,"ques":" 二叉树的中序遍历","analysis":"题目描述\r\n给定一个二叉树，返回它的中序 遍历。\r\n\r\n示例:\r\n输入: [1,null,2,3]\r\n   1\r\n    \\\r\n     2\r\n    \/\r\n   3\r\n\r\n输出: [1,3,2]\r\n\r\n\r\n分析与解法\r\n前序遍历：先访问该节点，然后访问该节点的左子树和右子树；\r\n中序遍历：先访问该节点的左子树，然后访问该节点，再访问该节点的右子树；\r\n后序遍历：想访问该节点的左子树和右子树，然后访问该节点。\r\n\r\n解法一\r\n递归\r\nclass Solution {\r\npublic:\r\n    vector<int> inorderTraversal(TreeNode* root) {\r\n        vector<int>res;\r\n        inorder(root,res);\r\n        return res;\r\n    }\r\n    TreeNode *inorder(TreeNode *root,vector<int>&res){\r\n        if(root==NULL)return NULL;\r\n        inorder(root->left,res);\r\n        res.push_back(root->val);\r\n        inorder(root->right,res);\r\n        return root;\r\n    }\r\n}
{"quesInfo":{"id":2817,"ques":"二叉树的层次遍历","analysis":"题目描述\r\n给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。\r\n\r\n例如:\r\n给定二叉树: [3,9,20,null,null,15,7],\r\n    3\r\n   \/ \\\r\n  9  20\r\n    \/  \\\r\n   15   7\r\n返回其层次遍历结果：\r\n[\r\n  [3],\r\n  [9,20],\r\n  [15,7]\r\n]\r\n\r\n\r\n分析与解法\r\n本题解析来源：\r\nhttps:\/\/www.cnblogs.com\/miloyip\/archive\/2010\/05\/12\/binary_tree_traversal.html?tdsourcetag=s_pcqq_aiomsg\r\n\r\n节点的定义:\r\nstruct Node {\r\n    Node *pLeft;\r\n    Node *pRight;\r\n    int data;\r\n}
{"quesInfo":{"id":2818,"ques":" 二叉树的最大深度","analysis":"题目描述\r\n给定一个二叉树，找出其最大深度。\r\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\r\n说明: 叶子节点是指没有子节点的节点。\r\n\r\n示例：\r\n给定二叉树 [3,9,20,null,null,15,7]，\r\n    3\r\n   \/ \\\r\n  9  20\r\n    \/  \\\r\n   15   7\r\n返回它的最大深度 3 。\r\n\r\n\r\n分析与解法\r\n如果二叉树为空，则深度为0 \r\n如果不为空，分别求左子树的深度和右子树的深度，去最大的再加1，因为根节点深度是1，要加进去。\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode *root) {\r\n        if(root == NULL)\r\n            return 0;\r\n        \r\n        int leftDepth = maxDepth(root->left);\r\n        int rightDepth = maxDepth(root->right);\r\n\r\n        return leftDepth > rightDepth ? (leftDepth + 1) : (rightDepth + 1);\r\n    }\r\n}
{"quesInfo":{"id":2819,"ques":"将有序数组转换为二叉搜索树","analysis":"题目描述\r\n将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。\r\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\r\n\r\n```\r\n\/**\r\n * Definition for binary tree\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * }
{"quesInfo":{"id":2820,"ques":"如何判断一个数是否是平衡二叉树?","analysis":"题目描述\r\n首先对题目进行解析, 题目中的平衡二叉树, 其本身是一种高度自平衡的树, 它的任何一个结点的左右子树的高度之差不会超过1.\r\n并且,每个根节点下面的左右子树也同时满足平衡二叉树的性质.\r\n\r\n递归解法1: \r\n对于本题,我们首先要知道如何去求左右子树是否平衡,接下来只要判断自己是否平衡即可.(弊端: 该方法是自顶向下判断,本身带有很多重复计算步骤.)\r\n```c\r\nclass Solution {\r\npublic:\r\n    bool IsBalanced_Solution(TreeNode* pRoot) {\r\n    \tif(pRoot==NULL)\r\n    \t\treturn 1;\r\n    \tint left=TreeDepth(pRoot->left);\r\n    \tint right=TreeDepth(pRoot->right);\r\n    \tint diff=left-right;\r\n    \tif(diff>1 || diffleft) && IsBalanced_Solution(pRoot->right);\r\n    }\r\nprivate:\r\n    int TreeDepth(TreeNode* pRoot)\r\n    {\r\n\t\tif(pRoot==NULL)\r\n\t\t\treturn 0;\r\n\t\tint left=TreeDepth(pRoot->left);\r\n\t\tint right=TreeDepth(pRoot->right);\r\n\t\treturn (left>right?left:right)+1;    \r\n    }\r\n}
{"quesInfo":{"id":2823,"ques":"二叉树展开为链表","analysis":"题目描述\r\n给定一个二叉树，原地将它展开为链表。\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    void flatten(TreeNode* root) {\r\n        if(root==NULL)return;\r\n        flatten(root->left);\r\n        flatten(root->right);\r\n        TreeNode *temp=root->right;\r\n        root->right=root->left;\r\n        root->left=NULL;\r\n        while(root->right)root=root->right;\r\n        root->right=temp;\r\n    }\r\n}
{"quesInfo":{"id":2828,"ques":"将有序数组转换为二叉搜索树","analysis":"题目描述\r\n将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。\r\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\r\n\r\n```\r\n\/**\r\n * Definition for binary tree\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * }
{"quesInfo":{"id":2829,"ques":"白板翻转二叉树","analysis":"题目描述\r\nMax Howell是苹果电脑上最受欢迎的homebrew程序的作者：谷歌有90%的工程师都在用homebrew。不过，Max在面试谷歌时因为不会在白板上写出翻转二叉树的代码而被拒绝了。\r\n\r\n如此神奇的翻转二叉树到底是怎么一回事呢，其实说来简单，就是把下图所示的这棵二叉树\r\n     4\r\n   \/   \\\r\n  2     7\r\n \/ \\   \/ \\\r\n1   3 6   9\r\n翻转成\r\n     4\r\n   \/   \\\r\n  7     2\r\n \/ \\   \/ \\\r\n9   6 3   1\r\n\r\n\r\n分析与解法\r\n解法一\r\n实际上，这个问题的难度不高，背后也没很深的数学知识，使用递归便很好解决，我们只要先invertBinaryTree(root.left and root.right)，然后再交换root.left和root.right即可。\r\n\r\nC++代码如下(已在leetcode上AC)\r\nclass Solution {\r\npublic:\r\n    TreeNode* invertTree(TreeNode* root) {\r\n        if(root == NULL)\r\n                {return NULL;}\r\n        else{\r\n            \/\/交换左右子树\r\n            TreeNode* temp = root->left;  \r\n            root->left = root->right;  \r\n            root->right = temp;  \r\n\r\n            \/\/ 继续递归\r\n            invertTree( root->left );  \r\n            invertTree( root->right); \r\n            \r\n            return root;\r\n        }\r\n    }\r\n}
{"quesInfo":{"id":2831,"ques":"二叉树的最近公共祖先","analysis":"题目描述\r\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\r\n\r\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\r\n\r\n例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]\r\n\r\n示例 1:\r\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\r\n输出: 3\r\n解释: 节点 5 和节点 1 的最近公共祖先是节点 3。\r\n\r\n示例 2:\r\n输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\r\n输出: 5\r\n解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。\r\n \r\n\r\n说明:\r\n所有节点的值都是唯一的。\r\np、q 为不同节点且均存在于给定的二叉树中。\r\n\r\n递归搜索左右子树，如果左子树和右子树都不为空，说明最近父节点一定在根节点。反之，如果左子树为空，说明两个节点一定在右子树；同理如果右子树为空，说明两个节点一定在左子树。\r\n```\r\n\r\n\/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * }
{"quesInfo":{"id":2834,"ques":"二叉树的合并","analysis":"题目描述\r\n给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。\r\n\r\n你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。\r\n\r\n示例：\r\n输入: \r\n\tTree 1                     Tree 2                  \r\n          1                         2                             \r\n         \/ \\                       \/ \\                            \r\n        3   2                     1   3                        \r\n       \/                           \\   \\                      \r\n      5                             4   7                  \r\n输出: \r\n合并后的树:\r\n\t     3\r\n\t    \/ \\\r\n\t   4   5\r\n\t  \/ \\   \\ \r\n\t 5   4   7\r\n注意: 合并必须从两个树的根节点开始。\r\n\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    \/\/  存储t1,t2合并之后的结果\r\n    TreeNode* t3 = new TreeNode(NULL);\r\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\r\n        t3 = merge(t1,t2,0);\r\n        return t3;\r\n    }\r\n    \/\/  t1,t2同时合并\r\n    TreeNode* merge(TreeNode* t1,TreeNode* t2,int level){\r\n        TreeNode* node = new TreeNode(NULL);\r\n        if(t1==NULL&&t2==NULL){\r\n            return NULL;\r\n        }else{\r\n            if(t1==NULL){\r\n                return t2;\r\n            }else if(t2==NULL){\r\n                return t1;\r\n            }else{\r\n                \/\/  值合并\r\n                node->val=t1->val+t2->val;\r\n                level++;\r\n                node->left=merge(t1->left,t2->left,level);\r\n                node->right=merge(t1->right,t2->right,level);\r\n            }\r\n        }\r\n        return node;\r\n    }\r\n}
{"quesInfo":{"id":2835,"ques":"滑动窗口最大值","analysis":"题目描述\r\n本题来源于leetcode第239题\r\n\r\n这道题本来我使用的是O(N^2)的方法，后来学习了LeetCode上别人的解法，在此记录一下。\r\n\r\n示例:\r\n输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3\r\n输出: [3,3,5,5,6,7] \r\n解释: \r\n  滑动窗口的位置                最大值\r\n---------------               -----\r\n[1  3  -1] -3  5  3  6  7       3\r\n 1 [3  -1  -3] 5  3  6  7       3\r\n 1  3 [-1  -3  5] 3  6  7       5\r\n 1  3  -1 [-3  5  3] 6  7       5\r\n 1  3  -1  -3 [5  3  6] 7       6\r\n 1  3  -1  -3  5 [3  6  7]      7\r\n注意：\r\n你可以假设 k 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。\r\n\r\n进阶：\r\n\r\n你能在线性时间复杂度内解决此题吗？\r\n\r\n这个方法使用了一个双端队列来保存来保存窗口中的数据的index，对这个队列的具体操作如下【虽然队列中保存的是index，但是为了方便描述，就直接描述为数据】：\r\n\r\n1. 在插入新数据的时候，如果队列为空就直接插入\r\n\r\n2. 如果队列不为空就判断新数据和队尾元素的大小，如果队尾元素小于新数据，那么我们可以确定，在包含队尾元素和新数据的窗口里面，一定是新数据最大，有了这个假设，我们就可以把队尾元素移除队列，然后重复这个比较，直到遇到一个比新数据大的数才停止出队列，然后再把新数据插入。\r\n\r\n这个就保证了，在队首的数据一定是当前窗口中最大的，然后队首后面的是次大的数据，依次类推，我们只需要在每次更新窗口的时候【因为只有更新窗口才会有新数据插入】把队首元素提取出来，即可得到结果\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector maxSlidingWindow(vector& nums, int k) {\r\n        if(nums.size() == 0 || k  nums.size()) return {}
{"quesInfo":{"id":2836,"ques":"合并K个排序链表","analysis":"题目描述\r\n合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\r\n\r\n示例:\r\n输入:\r\n[\r\n  1->4->5,\r\n  1->3->4,\r\n  2->6\r\n]\r\n输出: 1->1->2->3->4->4->5->6\r\n\r\n在 合并两个有序链表 的基础上，我们很容易想到第一种解法，首先我们将第一个链表和第二个链表合并成一个新的链表，然后再往后依次合并接下来的每个链表即可。\r\n\r\n假设每个链表结点数一样都为 n，第一次合并时，要遍历 2n 个结点，往后则要分别遍历 3n, 4n, … , kn 个结点。可以看到，每次进行合并时都要将之前所有的链表遍历一次，因此这个方法的时间复杂度较高，为 O((k(k+1)2−1)∗n) O((\\frac{k(k+1)}{2} - 1) * n)O(( \r\n2\r\nk(k+1)\r\n\t\r\n −1)∗n)。\r\n\r\n```\r\n\r\nclass Solution {\r\npublic:\r\n    ListNode* mergeKLists(vector& lists) {\r\n        \r\n        int k = lists.size(); \/\/ 链表个数\r\n        \r\n        if (k >= 2)\r\n        {   \r\n            \/\/ 先将前两个链表合并为一个新链表，再把新链表依次和后面的链表合并\r\n            ListNode *head = mergeTwoLists(lists[0], lists[1]);\r\n            for (int i = 2; i < k; i++)\r\n            {\r\n                head = mergeTwoLists(head, lists[i]);\r\n            }\r\n            \r\n            return head;  \r\n        }\r\n        else if (k == 1)\r\n        {\r\n            return lists[0];\r\n        } \r\n        else\r\n        { \r\n            return NULL;\r\n        }\r\n        \r\n    }\r\n    \r\n        ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\r\n        \r\n        ListNode *head = new ListNode(0); \/\/ 新建哨兵结点，方便操作\r\n        ListNode *temp = head;\r\n        \r\n        \/\/ 依次比较两个链表的结点值，将值较小的结点插入到新建的链表后面\r\n        while(l1 && l2)\r\n        {\r\n            if (l2->val val)\r\n            {\r\n                temp->next = l2;\r\n                temp = temp->next;\r\n                l2 = l2->next;\r\n            }\r\n            else\r\n            {\r\n                temp->next = l1;\r\n                temp = temp->next;\r\n                l1 = l1->next;\r\n            }\r\n        }\r\n        \r\n        \/\/ 其中一个链表比较完毕，将另外一个链表剩余结点直接插入到新建的链表后面\r\n        if (l1)\r\n        {\r\n            temp->next = l1;\r\n        }\r\n        else\r\n        {\r\n            temp->next = l2;\r\n        }\r\n        \r\n        temp = head;\r\n        head = head->next;\/\/ 删除哨兵结点\r\n        delete(temp);\r\n        \r\n        return head;  \r\n    }\r\n}
{"quesInfo":{"id":2837,"ques":"用队列实现栈","analysis":"题目描述\r\n使用队列实现栈的下列操作：\r\npush(x) -- 元素 x 入栈\r\npop() -- 移除栈顶元素\r\ntop() -- 获取栈顶元素\r\nempty() -- 返回栈是否为空\r\n\r\n注意:\r\n你只能使用队列的基本操作-- 也就是 push to back, peek\/pop from front, size, 和 is empty 这些操作是合法的。\r\n你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\r\n你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。\r\n\r\n        因为栈和队列的存储方式是完全相反的，所以这里用到两个队列。\r\n\r\n        当有新元素要push时，用一个队列暂时存储之前的栈，另一个队列pop空，先压入新元素，再把暂时存储之前的栈的队列再一次push进队列中。\r\n\r\n        这样，队列中的元素顺序就是栈结构的顺序了。\r\n\r\n```\r\n\r\nclass MyStack {\r\npublic:\r\n    \r\n    queue q1,q2;\r\n    \/** Initialize your data structure here. *\/\r\n    MyStack() {\r\n        \r\n    }\r\n    \r\n    \/** Push element x onto stack. *\/\r\n    void push(int x) {\r\n        while(!q2.empty()) {\r\n            q1.push(q2.front());\r\n            q2.pop();\r\n        }\r\n        q2.push(x);\r\n        while(!q1.empty()) {\r\n            q2.push(q1.front());\r\n            q1.pop();\r\n        }\r\n        \r\n    }\r\n    \r\n    \/** Removes the element on top of the stack and returns that element. *\/\r\n    int pop() {\r\n        int a = q2.front();\r\n        q2.pop();\r\n        return a;\r\n    }\r\n    \r\n    \/** Get the top element. *\/\r\n    int top() {\r\n        return q2.front();\r\n    }\r\n    \r\n    \/** Returns whether the stack is empty. *\/\r\n    bool empty() {\r\n        return q2.empty();\r\n    }\r\n}
{"quesInfo":{"id":1435,"ques":"运行下面的代码，输出是什么？\r\nclass A  \r\n{  \r\n}
{"quesInfo":{"id":1442,"ques":"单向链表的反转","analysis":"经常被问到的一个面试题，也是一个非常基础的问题。比如一个链表是这样的： 1->2->3->4->5 通过反转后成为5->4->3->2->1。\r\n\r\n最容易想到的方法遍历一遍链表，利用一个辅助指针，存储遍历过程中当前指针指向的下一个元素，然后将当前节点元素的指针反转后，利用已经存储的指针往后面继续遍历。源代码如下：\r\n\r\nstruct linka {int data;linka* next;}
{"quesInfo":{"id":2649,"ques":"new操作符的作用是什么?","analysis":"作用如下。\r\n\r\n（1）创建一个空对象。\r\n\r\n（2）由this变量引用该对象。\r\n\r\n（3）该对象继承该函数的原型（更改原型链的指向）。\r\n\r\n（4）把属性和方法加入到this引用的对象中。\r\n\r\n（5）新创建的对象由this引用，最后隐式地返回this，过程如下。\r\n\r\nvar obj  = {}
{"quesInfo":{"id":2537,"ques":"寻找热门查询\r\n搜索引擎会通过日志文件把用户每次检索所使用的所有查询串都记录下来，每个查询串的长度为1～255字节。假设目前有1000万条查询记录（但是，因为这些查询串的重复度比较高，所以虽然总数是 1000 万，但如果除去重复后，查询串query不超过300万个），请统计其中最热门的10个查询串，要求使用的内存不能超过1 GB。","analysis":"分析：一个查询串的重复度越高说明查询它的用户越多，也就是越热门。如果是1亿个IP求Top 10，可先00将IP分到1000个小文件中去，并保证一个IP只出现在一个文件中，再对每个小文件中的IP进行hash_map统计并按数量排序，最后用归并或者最小堆依次处理每个小文件中的Top 10以得到最后的结果。\r\n\r\n但是对于本题，是否也需要先把大文件弄成小文件呢？根据题目描述，虽然有1000万个查询，但是因为重复度比较高，去除重复后，事实上只有300万个查询，每个查询为255字节，所以可以考虑把它们全部放进内存中去（假设300万个字符串没有重复，都是最大长度，那么最多占用内存3000000 × 255 = 765MB=0.765GB，所以可以将所有字符串都存放在内存中进行处理）。\r\n\r\n考虑到本题中的数据规模比较小，能一次性装入内存，因而放弃分而治之\/散列映射的步骤，直接用hash_map统计，然后排序。事实上，针对此类典型的Top k问题，采取的对策一般都是“分而治之\/散列映射（如有必要）+ hash_map+堆”。\r\n\r\n解法：\r\n（1）hash_map统计。对这批海量数据进行预处理，用hash_map完成频率统计。具体做法是：维护一个键为query、value为该query出现次数的hash_map，即hash_map(query, value)，每次读取一个query，如果该query不在hash_map中，那么将该query放入hash_map中，并将它的value值设为1；如果该query在hash_map中，那么将该query的计数value加1即可。最终我们用hash_map在O(n)的时间复杂度内完成了所有query的频率统计。\r\n\r\n（2）堆排序。借助堆这种数据结构，找出Top k，时间复杂度为O(n'logk)。也就是说，借助堆可以在对数级的时间内查找或调整移动。因此，维护一个k（该题目中是10）大小的最小堆，然后遍历300万个query，分别和根元素进行比较，最终的时间复杂度是O(n) + O(n'logk)，其中n为1000万，n'为300万。\r\n\r\n关于上述过程中的第2步（堆排序），进一步讲，可以维护k个元素的最小堆，即用容量为k的最小堆存储最先遍历到的k个数，并假设它们就是最大的k个数，建堆费时O(k)，有k1 > k2 >…> kmin（设kmin为最小堆中最小元素）。继续遍历整个数列剩下的n−k个元素，每次遍历一个元素x，将其与堆顶元素进行比较，若x > kmin则更新堆（x入堆，每次调整堆费时O(log k)），否则不更新堆。这样下来，总费时O(k + (n−k)log k ) = O(nlogk)。此方法得益于在堆中查找等各项操作的时间复杂度均为O(log k)。\r\n\r\n当然，也可以采用Trie树，结点里存该查询串出现的次数，没有出现则为0，最后用10个元素的最小堆来对出现频率进行排序。\r\n\r\n本题解析节选自July一书《编程之法：面试和算法心得》第六章 海量数据处理。","type_id":3,"diff":1,"isdelete":1,"created_time":"2018-05-30 18:37:07","update_time":"2018-05-30 18:37:55","is_show":1,"is_coll":0},"list":[{"is_coll":0,"is_done":0,"ques_id":1447,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":1448,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":1449,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":1450,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":1451,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2536,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2537,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2538,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2539,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2540,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2541,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2542,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2543,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2544,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2545,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2546,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2547,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2548,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2549,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2550,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2551,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2552,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2553,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2554,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2555,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2556,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2557,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2558,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2559,"category_id":"3"},{"is_coll":0,"is_done":0,"ques_id":2560,"category_id":"3"}]}


['https://www.julyedu.com/question/big/kp_id/23/ques_id/2601', 'https://www.julyedu.com/question/big/kp_id/23/ques_id/2916', 'https://www.julyedu.com/question/big/kp_id/26/ques_id/3010', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2081', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2767', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2771', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2774', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2775', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2777', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2779', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2785', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2787', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2789', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2791', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2792', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2794', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2798', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2800', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2801', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2804', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2808', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2809', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2810', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2811', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2814', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2816', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2817', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2818', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2819', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2820', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2823', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2828', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2829', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2831', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2834', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2835', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2836', 'https://www.julyedu.com/question/big/kp_id/2/ques_id/2837', 'https://www.julyedu.com/question/big/kp_id/4/ques_id/1435', 'https://www.julyedu.com/question/big/kp_id/4/ques_id/1442', 'https://www.julyedu.com/question/big/kp_id/21/ques_id/2649', 'https://www.julyedu.com/question/big/kp_id/3/ques_id/2537']